* finish all main points of network code and process logic
- est 4 days FT

* finish all main points of spreadsheet summary sheets
- est 3 days week full time

* read parts of algorithms book chapters 2,3,4,5,6,7, then 10,11,12,13, then 18
* do all basic of algorithms bit
- est 7 days full time

* doc a bit better
- remove works in progress bit from index.htm
- est 1 day FT

- ideas from "ideas removed" file - infinite

////
git change log:

nowish:
- Bank EnactFuture, EnactBuy, ShipDeparted, shiparrived, futuresettlements
- finish binary search tree
- read about + implement rb trees, b-trees
- shippingcomps need to know distance between ports to work out how long journeys take, and banks need to know to work out how much shipping companies should charge for movements. copy sql query loop from tfp python code. needs to be stored in a dict of string -> distance (string will be of form "city1,city2" by both shippingcomp and bank, so put function to create lookup table in economicplayer.
- trader MoveAccepted, buyconfirmed, futuresettled, SurplusForecast, shortageforecast
- fandgw "time" in DecideCommodPriceJumps
- shippingcompany moveconfirmed, DecideArrivals

general reading:
- read more about linear programming, graph problems
- read more about tsp (see links, also my two books on algorithms and computing theory)
- read more detail from algs book

////

Process logic and networking:
- in server, clients should get removed from clients list if they are disconnected
- net_msg_todo.txt
- unit test individual functions
- probably use sql spatial functions to work out distances for freighter travel - both for Bank and for Resolver

///

Then a load of database query sheets
 - Prices are converted from local currency to historical USD value

////

testing:
- write tests for multihead queue and syncqueue
- unittest only bank can write to db
- make processes do right thing when other processes go down, and have automated tests for all possibilities if differing orders of collapse.
- unittest the algoserver data structures
- some sort of test that does create db, then start all processes, then run 10 seconds, then bunch of sql queries, then check data is sane
- unittest multiheadqueue
- test: fandandgw should keep track of its last tick time, if current tick time is the same time, skip
- test that targeted messages are sent only to the correct server/client, and have exact steps to reproduce the test (inc fandgw to trader surplus and shortage)

////

still need to implement the following:
- binary search tree
- red-black tree
- b-tree

still need to unit test the following:
- hash table
- counting sort

- switch counting sort to only find max value once, before iterations or timer begin
- do soap methods for manipulating data structures

///

doc:

The name is a nod to book Tai Pan, that is the general point is that there are several large trading houses which ferry various goods very long distances, though actually here the trading houses have been split into two distinct entities, the "Shipping companies" who do the actual transporting of goods, and the "traders" who predict surpluses and shortages in the market and buy and sell goods accordingly.

One day the description here, description in index.htm, description on CV, and description in Wolfie will all need to be synced...

Also make sure names match up UML <-> sql and vice versa

- release.bat - copy across sql scripts, AlgoServiceProxy.dll, dll creation script, Resolve.rsl and associated .pys, README, howtorun, web, wpfchart compiled version and source, precompiled statslib and source, a note on how this is a cut down static sql version without all the c# processes and include fact doc is in web dir

short version for CV etc:

•	A C# .NET, SQL Server and Python project written to improve my knowledge of various aspects of computer science and software engineering. A large number of heterogeneous, multithreaded C# processes interact with each other via TCP sockets. Much of the underlying state of the system is stored in a MS SQL Server instance.

The system includes implementations of various data structures (e.g. B-Trees, hash tables), numerous sorting algorithms, and algorithms for simulating stochastic processes. A user interface to the system is provided in the form of an IronPython-based spreadsheet that a) makes numerous queries on both the database and on a C# SOAP web service b) loads a C# WPF assembly to produce interactive graphs of the summary data and c) utilises a mathematical optimization framework to solve a linear programming problem, using data from the rest of the system.

The project is described by a series of UML diagrams, and partly covered by unit tests. The source code is available on GitHub. Around 300 hours work so far.

