* finish all main points of network code and process logic
- est 4 days FT

* finish all main points of spreadsheet summary sheets
- est 3 days week full time

* read parts of algorithms book chapters 2,3,4,5,6,7, then 10,11,12,13, then 18
* do all basic of algorithms bit
- est 8 days full time

* read algorithms book chapters 22, 29, 34, 35, and a bunch of TSP/MS Solver stuff
* do TSP stuff
- est 4 days FT

* doc a bit better
- proper index.htm + screenshots
- add version with static sql data to resolver exchange
- est 2 days FT

- ideas from "ideas removed" file - infinite

////
git change log:


nowish:
- redo screenshoot for TSP graph - I think the solution may well be wrong
- read more about linear programming, graph problems, tsp
- fandandgw should keep track of its last tick time, if current tick time is the same time, skip
- read more detail from algs book
- finish binary search tree
- sql server process CPU usage way too high, fix it (+ doc)
- read about + implement binary search trees, rb trees, b trees
- for clients keeping track of server ids, need to store connections in a dict
- shippingcomps need to know distance between ports to work out how long journeys take, and banks need to know to work out how much shipping companies should charge for movements. copy sql query loop from tfp python code. needs to be stored in a dict of string -> distance (string will be of form "city1,city2" by both shippingcomp and bank, so put function to create lookup table in economicplayer.
- traderClient.Send in ShippingCompany - sent to only one client, also server tcp thread needs to note id of sender for MoveAdvertised 
- Bank EnactFuture, EnactBuy, ShipDeparted, shiparrived - all need to note id of sender
- trader MoveAccepted, buyconfirmed, futuresettled, SurplusForecast, shortageforecast
- fandgw DecideCommodPriceJumps
- shippingcompany MoveAdvertised, moveconfirmed, DecideArrivals
- when bank process starts, it should clear all warehoused commods and futures

////

Process logic and networking:
- in server, clients should get removed from clients list if they are disconnected
- net_msg_todo.txt
- unit test individual functions
- probably use sql spatial functions to work out distances for freighter travel - both for Bank and for Resolver
- test that targeted messages are sent only to the correct server/client, and have exact steps to reproduce the test (inc fandgw to trader surplus and shortage)

///

Then a load of database query sheets
 - Prices are converted from local currency to historical USD value

////

Fourthly, extreme contrivedness:
8. Travelling freighter problem
- integrate better with my model

links:

tsp generally:
http://archive.ite.journal.informs.org/Vol7No1/LeeRaffensperger/
http://iris.gmu.edu/~khoffman/papers/trav_salesman.html
http://en.wikipedia.org/wiki/Travelling_salesman_problem

solver foundation generally:
http://code.msdn.microsoft.com/solverfoundation
http://yetanothermathprogrammingconsultant.blogspot.com/2009/02/ms-solver-foundation-gurobi-2.html
http://yetanothermathprogrammingconsultant.blogspot.com/2009/02/tsp-powerset-formulation.html
http://blogs.msdn.com/lengningliu/archive/2009/11/04/using-solver-foundation-and-plug-in-solvers-in-ironpython.aspx
http://www.amsterdamoptimization.com/msf.html

both together:
http://blogs.msdn.com/natbr/archive/2009/04/27/solving-traveling-salesman-problems-using-solver-foundation.aspx
http://blogs.msdn.com/natbr/archive/2009/05/07/solver-foundation-tsp-part-ii-directives-solver-plugins-model-libraries.aspx

also:
http://en.wikipedia.org/wiki/Linear_programming
http://en.wikipedia.org/wiki/Priority_queue

///

testing:
- write tests for multihead queue and syncqueue
- unittest only bank can write to db
- make processes do right thing when other processes go down, and have automated tests for all possibilities if differing orders of collapse.
- unittest the algoserver data structures
- unittest multiheadqueue

////

still need to implement the following:
- binary search tree
- red-black tree
- b-tree

still need to unit test the following:
- hash table
- counting sort

- switch counting sort to only find max value once, before iterations or timer begin
- do soap methods for manipulating data structures

///

doc:

The name is a nod to book Tai Pan, that is the general point is that there are several large trading houses which ferry various goods very long distances, though actually here the trading houses have been split into two distinct entities, the "Shipping companies" who do the actual transporting of goods, and the "traders" who predict surpluses and shortages in the market and buy and sell goods accordingly.

One day the description here, description in index.htm, description on CV, and description in Wolfie will all need to be synced...

Also make sure names match up UML <-> sql and vice versa

- release.bat - copy across sql scripts, AlgoServiceProxy.dll, dll creation script, Resolve.rsl and associated .pys, README, howtorun, web, wpfchart compiled version and source, precompiled statslib and source, a note on how this is a cut down static sql version without all the c# processes and include fact doc is in web dir

short version for CV etc:

•	A C# .NET, SQL Server and Python project written to improve my knowledge of various aspects of computer science and software engineering. A large number of heterogeneous, multithreaded C# processes interact with each other via TCP sockets. Much of the underlying state of the system is stored in a MS SQL Server instance. The system includes implementations of various data structures (e.g. B-Trees, hash tables), numerous sorting algorithms, and algorithms for simulating stochastic processes. A user interface to the system is provided in the form of an IronPython-based spreadsheet that a) makes numerous queries on both the database and on a C# SOAP web service b) loads a C# WPF assembly to produce interactive graphs of the summary data and c) utilises a mathematical optimization framework to solve a linear programming problem, using data from the rest of the system. The project is described by a series of UML diagrams, and partly covered by unit tests. The source code is available on GitHub. Around 300 hours work so far.

