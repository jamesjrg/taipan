* Read Professional C# 2008 chapter 1/2 41 (tcp sockets)
- currently at pdf page 1508
- add back silly proejcts to wolfie, inc phrase "mathematically prove blah blah with a 2D animation of..." for no fly
* get basics of database schema all working
* get basics of interacting processes and logic of their interactions working, using test driven development
- est 3 weeks full time

* Read a bit more of learning UML
* do some more UML diagramming
- est 2 days full time

* Read database management systems chapters 3 (almost read already), 4, 5
* write first attempt at Resolver One view + WPF graphing, including monte carlo GBM walking
- est 3 weeks full time

* read parts of algorithms book
* do algorithms bit
- est 3 weeks full time

- ideas about database normalisation and tuning - est 4 days FT
- ideas about more efficient network code - est 1.5 weeks FT
- ideas about trade optimisation problem - est 3.5 weeks FT

////

fairly immediate stuff:

concurrency:
- add all server+client addresses+ports to config files
- ensure tcp listener closes when program closes - remember it is in its own thread

sql:
- write sql for foreign keys and triggers
- add more SQL script which creates all the initial data
- add companytypecheck for freighter (see uml)
- add checks on interface between base + derived tables (see web page bookmark)
- add constraint on currency to have short name 3 upper case chars (UML and sql)

resolver:

other:
- make sure everything is shut down correctly, including if fail in init

///

Overall plan: lots of C# processes representing entities in a trading economy communicate with each other via XML, some as servers, some as clients, some as both. Most state is contained within a SQL server database, and only one of the processes (the "Bank", the name being a nod to Monopoly). The name is a nod to book Tai Pan, that is the general point is that there are several large trading houses which ferry various goods very long distances, though actually here the trading houses have been split into two distinct entities, the "Shipping companies" who do the actual transporting of goods, and the "traders" who predict surpluses and shortages in the market and buy and sell goods accordingly.
One day the description here, description in index.htm, description on CV, and description in Wolfie will all need to be synced...

Though some of this should be configurable, a reasonable ball park figure might be that we want to have running 10 Domestic Companies, 5 Shipping Companies, 5 Traders, 1 FateAndGuesswork, 1 FXService, 1 Bank, 1 Resolver One spreadsheet, 1 SQL Server instance.

DomesticCompany
Servers it polls for input as client:
1. FateAndGuesswork: it discovers when it will have a shortage or surplus of a given commodity, and at what price it will be wish to buy/sell to make up for this
Information it broadcasts as server:
1. that is has a shortage/surplus of a given commodity, and the price at wish it wishes to buy/sell to make up for this
Things it calculates:
Things it reads from database: nothing?

Trader
Servers it polls for input as client:
1. FateAndGuesswork for predicted future prices
2. DomesticCompany declarations of shortage
Information it broadcasts as server:
1. decisions to buy goods at a given port, and decisions to organise a futures contract
2. Contracts for movement of goods (from, to, expires)
3. Acceptances and denials of contracts for movement of goods (to shipping companies)
4. Decision to sell warehoused goods
Things it calculates:
1. On basis of distance between ports and also predicted information on future shortage or surplus of a given commodity for a given company, they calculate the most profitable places to buy goods to warehouse in readiness to sell (i.e. somewhere nearby to and cheap for predicted future shortage, possibly the same port), or to organise a futures contract to buy goods in future in readiness to buy (i.e. at the actual port of the predicted future surplus). Then when price fluctuation actually happens, warehoused goods are sold to nearest place that has a demand for those goods, or otherwise futures contract is fufilled and goods are again sold in most profitable way possible. Though unforseen variation and/or the error in the prediction by fate and guesswork could still lead to them losing money.
2. Between contract for movement of goods being accepted and the contract being removed from broadcast, there is a 10 second delay (represents e.g. finalizing negociations). Therefore has to maintain locks on open contracts for movement of goods.
Things it reads from database: distance between ports, which ports import/export a given commodity
Things it writes to database: none

ShippingCompany
Servers it polls for input as client:
1. Available contracts for movement of goods from traders
2. Whether acceptance of movement of goods has been confirmed
Information it broadcasts as server:
1. Acceptance of contract to move goods
2. when it has collected goods, when it has delivered goods. Once bank confirms receipt of message, sent info can be removed from broadcast. See "Trade" database entity for attributes to broadcast.
Things it calculates:
Things it reads from database: 

FXServer
Information it broadcasts as server:
1. fluctuating currency prices
Things it calculates: fluctuating currency prices via GBM
Things it reads from db: info on currencies (at startup only?)

Bank:
Servers it polls for input as client:
1. FX Server for FX prices. Updated currency value then written to database.
2. Shipping company departures and arrivals. On departure money is debited from trader and credited to both shipping company and seller, on basis of distance of journey. On arrival money is debited from buying company and credited to trader.
3. FateAndGuesswork market prices. Commodity prices in database are updated accordingly.
4. FateAndGuesswork stock prices. Database updated accordingly
5. trader decisions to buy goods to warehouse or to organise a futures contract. db updated accordingly.
6. domestic company declarations of shortage/surplus
7. trader decisions to sell warehoused goods
Information it broadcasts as server: none
Things it calculates:
1. whenever updating bank balances after an economic transaction, if movement it applies modifier from distance (= greater profit to freighter company, greater expense to trader), if trade in goods on open market takes into account current commodity price, if different currencies applies current FX multiplier
2. carries out futures contracts at point in time specified
3. sells warehoused goods at point traders decide to do so

Things it reads from database: nothing
Things it writes to database: see above

FateAndGuesswork
Servers it polls for input as client: none
Information it broadcasts as server:
Calculated future shortages or surpluses of a given commodity for a given company are broadcast (note only companies_with_location which actually import/export a given commodity will ever produce a surplus/suffer shortage). These are broadcast on two channels: 
1. Guesswork, with an added degree of error, is for Traders to pick up. The next Trader to poll FateAndGuesswork is given the information, and this information is then removed from the queue. two, without any error
2. Fate, it will also broadcast this same information, but without any error, to be picked up by the PublicCompanies. Once received this too is removed from the queue.
Furthermore, there is:
3. Current market price of all commodities. Goes up and down via GBM. Make sure places which neither import nor export a commodity do not have a price created (unit test this, also take account of this in GUI)
4. Stock prices of each company. Goes up and down via GBM.
Things it calculates:
Semi-randomly calculates which PublicCompanies will in future have a) have surplus of a commodity or b) have shortage of a commodity, of how much quantity (though never more than can fit in one freighter), and at what price they will wish to buy/sell above/below market to make up for this. Primary sector companies more usually have goods available for sale, service sector usually have requests for goods to buy, manufacturing sector more a mixture of the two
Things it reads from database: info on commodities (at startup only?).
Things it writes to database: none

////

Resolver spreadsheet/Python code:

(CU) = optional constant update

List of diff tab displays required:
1. Given a commodity name, display historical prices of that commodity at each port (CU)
2. Display historical prices of all public companies (CU)
3. Display historical market cap of all public companies (CU)
4. Display historical price of all currencies (CU)
5. Historical futures contracts, including details of how relevant prices of all involved values changed between start and end of contract, and profit made (CU)
6. Historical warehousing of commodities, including details of how relevant prices of all involved values changed between start and end of contract, and profit made (CU)
7. Summary data on comparative historical record of countries, split into time periods - in each time period have the number of each type of transaction carried out, total value of transactions, and the number + value of transactions in each economic sector
7. As above, but with ports
8. Historical commodity transports
9. Summary data for each shipping company, split into time periods - number of transactions, number of different ports served, average quantity per load, min quantity in a single load, max quantity in a single load

Where relevant, tabs should have:
1. Button to switch on constant update
2. Button to draw line graph - should be able to have multiple graphs at once, should be able to alter number of lines included on graph
3. Button to draw random walk predicted future graph - present data as a solid line, then a bunch of dashed lines for various possibilities

random walking to use Markov Chain monte carlo methods
- Ideally I would use Solver Foundation, though could also try scipy
http://www.scipy.org/Cookbook/FittingData
http://code.msdn.microsoft.com/solverfoundation
http://en.wikipedia.org/wiki/Markov_chain_Monte_Carlo

- WPF graph program - just local, follow Resolver Exchange example. Can tell the server to create new windows, or you can add new data points to old windows, or close windows
- graph windows to include help instructions

////

Database stuff (needs adding to both a) UML diagram and b) actual SQL scripts):

- For all tables with historical values, have the current value updated via a trigger linked to a new record being inserted into the main table
- maybe constraint on linking ports + commodities + prices: every commodity for every port must appear in link table, no null values allowed for either FK
- some commodities: steel, paper, electronics, cereal, textiles, oil, opium, precious gems, look on wikipedia for main exports of various countries
- constraints to ensure CompanyType is correctly enforced and instances can be neither multiple base classes nor multiple sub classes
- same with PublicCompanyType
- maybe add some views for use by the various processes that need info from database?
- do some normalisation some time after the design has changed a bit, and doc how I carried this out, and doc what normal form the db is in
- note that publiccompany includes countryid and then this info repeated as portid in derived domesticcompany. however, countryid needed to know what currency stock pirce is in. i think maybe this lack of normalisation needs to be noted and accepted. or otherwise, could make seperate shippingcompany table with countryid, and then remove countryid from publiccompany.
- make sure indexes, triggers, fks and pks, and constraints match up UML <-> sql and vice versa
- maybe make constraint that ensures PortCommodityPrice includes each commodity and port combination exactly once?
- make selects + updates to db use stored procedures for efficiency? if so, doc (and also, in brief buzz word doc, "x stored procedures")
- error handling on error being returned on database query

////

testing:
- test taipan-r cannot write to db
- Database interaction and calculations on that data based on database data well suited to unit testing, do these parts via TDD (and doc this fact).
- However multi-thread and multi-process concurrent aspects of program are not suited to normal unit testing frameworks, due to non-deterministic nature in which multiple threads and processes can interact. Explore CHESS, ideally use, doc, and add to wolfie:
http://blog.decarufel.net/2009/05/how-to-test-your-multi-threaded-code.html
http://research.microsoft.com/en-us/projects/chess/download.aspx

at very least, test basic interactions of individual processes going down with either some batch automation tests or just a text file with a list of things to manually test. Like, as a start:
- if any one server goes down, can other servers cope as well as can possibly be expected?
- can different servers get out of sync?
- if one server goes down and then comes back up again, can information accidentally be lost in the crash?

////

UML diagrams:

SQL:
- add constraints, indexes
- maybe add data type for each attrib
- maybe make currency short name the key, or at least make unique

Communication view:
- it should have title "Tai-Pan: ????"
- should be much the same as the deployment view, except without repeating the things there can be multiple of, and it should show which directions each communication can go in, and briefly describe the data transferred by each link

Deployment view:
- add the correct protocol labels
- maybe there need to be more communication links?
- add wpf graphs (same node as spreadsheet)

Also:
a UML diagram for internal working of FateAndGuesswork - showing threads and data created and served by them

////

Variation of price of stocks and commodities

http://en.wikipedia.org/wiki/Geometric_Brownian_motion

I think this is right:

a) use the analytic solution of the equation for GBM, which requires an initial value, two constants, the explanatory variable (time) and Wt
b) make Wt a random variable chosen from a normal distribution with mean 0 and standard deviation equal to the tick time

//////

algorithms bit:

- using info both in algos book and database book, have an entirely pointless "Pointless sorting server" (including on UML diagram, with a note of explanation) that takes a list of strings as input, and then sorts the list a method of the callers choice:
- merge sort
- quick sort
- heap sort
- hash table
- b tree

- uses WCF to provide RPC-style network service

///

doc:

- describe use of bank as mediator to db as design pattern (mayvbe mediator?), mention any other patterns used

- see CV for project summary, this is an old version:
•	A C# .NET, SQL Server and Python project written to improve my knowledge of various aspects of software development and computer science. A large number of heterogeneous C# processes interact by sending each other messages via TCP network connections. These processes are themselves multi-threaded to various levels of complexity. These processes also interact with an MS SQL Server instance which stores the underlying state of the system.
•	The front end utilises the spreadsheet/Python "mash up" “Resolver One” to provide analysis of the real time data from the database. The spreadsheet’s Python code is linked to a copy of Microsoft's Solver mathematical modelling library. Solver is used both to solve an optimization problem posited by the system, and also to provide Monte Carlo random walk data on how the stochastic processes within the system may behave. A local C# service is called by the spreadsheet script to create WPF graphs of summary data on request.
•	One final, especially contrived C# service provides an RPC-style interface whereby it takes a list of unsorted strings and returns the list in alphabetical order. Arguments provided by the caller specify which of a variety of differing algorithms or data structures should be used to perform the sorting.
•	I created a series of UML diagrams to describe various aspects of the system. The non-concurrent parts of the system were written using Test Driven Development, the multi-threaded parts of the system were tested using Microsoft's CHESS (a model checker for concurrent systems). The multi-process aspects of the system unfortunately do not have an automated testing strategy in place. As with all my projects since around 2004, the source is under version control (in this case git).


- add Solver Foundation+OML to doc+wolfie
- add xml + stuff on wpf graph server to uml+doc+wolfie
- add web services to wolfie

////

Keeping track of time:

up to 28 feb: 66
mar 1: 5
apr 1: 2
2 - 8: 23.25
9: 10
10: 0.5
11: 3.5
