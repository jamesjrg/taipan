* finish all main points of database schema
- est 4 days FT

* finish all main points of network code and process logic
- est 2.5 weeks FT

* Read database management systems chapters 4, 5
* finish all main points of Resolver One view + WPF graphing, including brownian GBM predicting
- est 2.5 weeks full time

* read parts of algorithms book
* do algorithms bit
- est 2.5 weeks full time

- ideas about database normalisation and tuning - est 1 week FT
- ideas about optimisation problem - est 1.5 weeks FT
- write script to stress test concurrent aspects - est 1 week FT
- ideas from "ideas removed" file - infinite

////

git changelog:

right now:
- do subscribe/unsub methods for multihead queue
- write tests for multihead queue
- make server use multihead queue
- add remaining sql foreign keys
- maybe constraint on PortCommodityPrice: every commodity for every port must appear in link table once and exactly once, no null values allowed for either FK
- add constraint shortage prob + import prob <=100
- check for comments on R1 and Solver

fairly immediate stuff:
general logic and network code:
- when a client connects to a server, server has to create a unique id for it and store this for syncing purposes. maybe this id should be same as that used for a) database and b) stored for each class? in which case clients provide their own id on connect, server cannot make it up.
- Trader/ShippingCompany interaction: delay of 5 secs between receiving acceptance of contract for movement of goods and taking contract off broadcast, requiring system of acks and locks, as in UML. But change design and UML a bit - rather than sending refusals, just make shipping companies have to assume they have been refused if they get no ack

other:
- improve start/testing batch scripts so can specify on command line how many of each process to start (then won't need separate test batch script, at least for now. quite possibly use Python.
- separate start script for starting up sortingserver + sortingclient together

////

First two tabs of Resolver sheet (GBM data streams):
1. Given a commodity name, display historical prices of that commodity at selected ports (CU)
2. Display historical price of selected currencies (CU)

Brownian random walk predicted future graph - present data as a solid line, then a bunch of dashed lines for various possibilities. This is mutually exclusive with constant update - pressing one deletes data from the other, perhaps, or maybe disable button.
Need to save a variable which says how many of the rows are real data, then this row is sent to brownian graph so it knows from where to draw dashed line.

brownian motion random walking:
use scipy
best link:
http://www.scipy.org/Cookbook/BrownianMotion
also:
http://www.scipy.org/Cookbook/FittingData
c = scipy.random.standard_normal((5,5,5) ?

- WPF graph program - just local, follow Resolver Exchange example. How does li ghaos orig code differ from altered version on resolver exchange? diff and investigate. Then use one or the other as a base - just copy and paste to start with. Should have ability to create new windows, or add new data to current windows (this functionality already in exchange example). add credit to ppl involved in making that sheet + wpf app. But also has option for real time update.
- real time update doesn't affect brownian graph
- graph windows to include help instructions

- maybe mention my thoughts on benefits of selective timed functions vs recalcualting whole workbook with RecalculateAfter

/////

Next two sheets:
4. Historical futures contracts, including details of how relevant prices of all involved values changed between start and end of contract, and profit made (CU)
5. Historical commdity transports, including details of how relevant prices of all involved values changed between start and end of contract, and profit made (CU)

Thirdly, summary data sets:
6. Summary data on comparative historical record of countries, split into time periods - in each time period have the number of each type of transaction carried out, total value of transactions, and the number + value of transactions in each economic sector. also country name, currency name.
7. Summary data for each shipping company, split into time periods - number of transactions, number of different ports served, average quantity per load, min quantity in a single load, max quantity in a single load. company name, number of freighters.

Fourthly, extreme contrivedness:
8. Travelling freighter problem

- //model.AssignmentNoDiag(city, assign);?

Maybe need to read about spatial data in sql - need to use "geography" data type
INSERT INTO SpatialTable (GeogCol1)
VALUES (geography::STPointFromText('POINT(-122.360 47.656)', 4326));
longitude is specified first before the latitude

Find the coordinates for perhaps just 10 of the ports for insertion, leave others null.

- represent all shipping lanes between ports as a graph of interconnected nodes, and do a "travelling freighter problem" solution of shortest route for a freighter to visit each port exactly once
- provide diagram of graph in doc

- use Resolver One and MS Solver Foundation
particularly relevant:
http://code.msdn.microsoft.com/solverfoundation
http://blogs.msdn.com/natbr/archive/2009/04/27/solving-traveling-salesman-problems-using-solver-foundation.aspx
http://blogs.msdn.com/natbr/archive/2009/05/07/solver-foundation-tsp-part-ii-directives-solver-plugins-model-libraries.aspx
http://yetanothermathprogrammingconsultant.blogspot.com/2009/02/ms-solver-foundation-gurobi-2.html
http://yetanothermathprogrammingconsultant.blogspot.com/2009/02/tsp-powerset-formulation.html
http://archive.ite.journal.informs.org/Vol7No1/LeeRaffensperger/
http://blogs.msdn.com/lengningliu/archive/2009/11/04/using-solver-foundation-and-plug-in-solvers-in-ironpython.aspx
http://en.wikipedia.org/wiki/Travelling_salesman_problem
http://en.wikipedia.org/wiki/Priority_queue

also:
http://www.amsterdamoptimization.com/msf.html

///

General Resolver things to do:
Possibly some vaguely sensible management (decisions on when to reuse + close) of the db connection?

////

Database stuff (needs adding to both a) UML diagram and b) actual SQL scripts):
- maybe add some views for use by the various processes that need info from database?
- do some normalisation some time after the design has changed a bit, and doc how I carried this out, and doc what normal form the db is in
- make sure indexes, triggers, fks and pks (and their names), and constraints (and their names) match up UML <-> sql and vice versa
- error handling on error being returned on database query

later SQL stuff:
- Read database management systems chapters 19, 20, 21
- do some database normalisation and tuning, and security management
- faff about with different sorts of indexes etc, maybe also so totally pointless striping, clustering, etc
- doc optimization/tuning
other ideas:
- views
- stored procedures
- faff with permissions and security and security schemas

////

testing:
- unittest only bank can write to db
- make processes do right thing when other processes go down, and have automated tests for all possibilities if differing orders of collapse.
- unittest the algoriths and data structures service
- unittest multiheadqueue
- However multi-thread and multi-process concurrent aspects of program are not suited to normal unit testing frameworks. just write some sort of stress test script - i.e. start loads and loads of processes and look for obvious problems - including crashing and incorrect answers in data. Doc this (inc CV desc)
- database connections should be closed when no longer needed

- use stress test to try to find any bottlenecks that can be optimised away, and if I find any doc this (maybe inc CV desc).
- need to think of some way of checking that servers have not gone out of sync

////

UML diagrams:

SQL:
- add add spatial stuff, table inheritance stuff, correct trigger names
- once project is finished, make sure it matches up with actual schema
- stuff that should be kept in sync includes: add table inheritance stuff, triggers, constraints
- maybe make currency short name the key, or at least make unique
- rearrange to be more tidy

Communication view:
- it should have title "Tai-Pan: ????"
- should be much the same as the deployment view, except without repeating the things there can be multiple of, and it should show which directions each communication can go in, and briefly describe the data transferred by each link

Deployment view:
- add the correct protocol labels
- maybe there need to be more communication links?

Seq view:
- needs more work?

////

Variation of price of stocks and commodities

http://en.wikipedia.org/wiki/Geometric_Brownian_motion

I think this is right:

a) use the analytic solution of the equation for GBM, which requires an initial value, two constants, the explanatory variable (time) and Wt
b) make Wt a random variable chosen from a normal distribution with mean 0 and standard deviation equal to the tick time

//////

algorithms bit:

- using info both in algos book and database book, have an entirely pointless "Pointless sorting server" (including on UML diagram, with a note of explanation) that takes a list of numbers as input, and then sorts the list a method of the callers choice:
- merge sort
- quick sort
- heap sort
- hash table
- red black tree
- b tree

- unit test
- uses WCF to provide RPC-style network service. perhaps the argument given for sorting method is an enum? or maybe a string attribute with options taken from a certain schema? look into how this is normally done.

///

doc:

One day the description here, description in index.htm, description on CV, and description in Wolfie will all need to be synced...

credit ppl from readme on web

The name is a nod to book Tai Pan, that is the general point is that there are several large trading houses which ferry various goods very long distances, though actually here the trading houses have been split into two distinct entities, the "Shipping companies" who do the actual transporting of goods, and the "traders" who predict surpluses and shortages in the market and buy and sell goods accordingly.

Mention how threads generally a bad idea, used as an exercise here, but in most real projects there are simpler, more reliable alternatives (i.e. asynchronous network read/writes, likely combined with callbacks for when data has finished sending or receiving, or otherwise combined with manual system of asynchronous acknowledgement messages between clients).

doc how even without 5 second delay in taking contracts for movements off broadcast, the multithreaded nature of system would mean it would be possible for two threads to simultaneously accept the same request anyway

- describe use of bank and db as mediator of many interactions in system, mention any other patterns used

shorter version for CV etc:

A C# .NET, SQL Server and Python project written to improve my knowledge of various aspects of software development and computer science. A large number of heterogeneous multithreaded C# processes interact with each other by sending and receiving messages via TCP sockets. These processes manipulate data using various algorithms and data structures for producing, sorting and manipulating sequences of numbers. Much of the underlying state of the system is stored in a MS SQL Server instance. A user interface is provided in the form of a Python-based spreadsheet. This is linked to a C# program for producing WPF graphs, and to Microsoft’s Solver Foundation and SciPy for simplistic mathematical modelling. The project also uses UML, unit testing, source control, etc. Around 160 hours work so far.

some phrases that could go in web doc:

A C# .NET, SQL Server and Python project written to improve my knowledge of various aspects of software development and computer science. A large number of heterogeneous multithreaded C# processes interact with each other by sending and receiving messages via TCP sockets. Much of the underlying state of the system is stored in a MS SQL Server instance. Only one of the processes has database write access, and hence acts as a mediator for many of the interactions.

The front end utilises the spreadsheet/Python "mash up" “Resolver One” to provide analysis of the real time data from the database. The Python spreadsheet uses Microsoft's Solver Foundation to solve a version of the Travelling Salesman Problem, and scipy to provide xxx fixme for some of the stochastic outputs of the system. A local C# program is called by the spreadsheet script to produce realtime WPF graphs on same aspects of this analysis.

One final, especially contrived C# service provides an RPC-style interface that takes a list of unsorted numbers and returns the list in alphabetical order. Arguments provided by the caller specify which of a wide variety of differing algorithms or data structures should be used to perform the sorting.

I created a number of UML diagrams to describe various aspects of the system. Some sections of the system are covered by unit tests, but much of the multithreaded and multiprocess code is not suited to this and is merely stress-tested. As with all projects I have worked on since around 2004 (commercial and non-commercial), the source is under version control (in this case git).

- talk about real time graphs on web
- add Solver Foundation+OML to web doc
- lots of xmlcomments for classes and methods (methods only necessary for public classes)
- triggers, constraints, (views?), etc
- web doc spatial database data - though utterly trivial use of spatial data because the database is not used to perform any operations on that data
- scipy
- solver foundation, travelling salesman


