* finish all main points of network code and process logic
- est 2.5 weeks FT

* Read database management systems chapter 5
* finish all main points of Resolver One view + WPF graphing, including GBM forecasting
- est 2.5 weeks full time

* read parts of algorithms book
* do algorithms bit
- est 2.5 weeks full time

- ideas about database normalisation and tuning - est 1 week FT
- ideas about optimisation problem - est 1.5 weeks FT
- ideas from "ideas removed" file - infinite

////

git changelog:

right now:
- add new server broadcast bank->trader
- change fxserver to only use decimal correct to 5 sf
- still need scaffolding for:
bank traderBroadcast
fateandguesswork traderBroadcast
shippingcompany bankBroadcast, traderBroadcast, traderPollers
trader bankBroadcast, shippingBroadcast, shippingPollers

- write tests for multihead queue
- Client messages needs thread control - i.e. make it private and add a "Dequeue" method to Client
- check for comments on R1

- format for Bank broadcast to trader
a) "buyconfirm,traderid,traderpacketid,warehouseid"
b) "futuresettle,traderid,traderpacketid,warehouseid"

- format for FateAndGuesswork broadcast to Trader, something like:
a) "traderid,surplus,Portname,CommodName,1200,2010-04-15T20:10:00"
b) "traderid,shortage,Portname,CommodName,1200,2010-04-15T20:10:00"

- format for messages from traders to shipping companies something like:
a) "advertise,myid,targetid,warehouseid"
b) "accept,myid,targetid,warehouseid"

- format for messages from trader to bank something like:
a) "buy,myid,madeuppacketid,portname,commodname,quantity"
b) "future,myid,madeuppacketid,portname,commodname,quantity,when"

- format for messages from shipping company to bank something like:
a) "departure,myid,warehouseid,depaturetime"
b) "arrival,myid,warehouseid,arrivaltime"
- format for messages from shipping company to traders something like:
a) "accept,myid,warehouseid"


fairly immediate stuff:
general logic and network code:
- Trader/ShippingCompany interaction: delay of 5 secs between receiving acceptance of contract for movement of goods and taking contract off broadcast, requiring system of acks and locks. Rather than sending refusals, just make shipping companies have to assume they have been refused if they get no ack

other:
- improve start py script so you can specify on command line how many of each process to start
- separate start script for starting up sortingserver + sortingclient together
- mega_start.bat script to start all C# processes at once (not Resolver though)

////

Process logic - make sure everything from overall plan.txt is working.
Unit test individual functions

///

First two tabs of Resolver sheet (GBM data streams):
- make the basic update buttons work correctly
- Brownian random walk predicted future graph - present data as a solid line, then a bunch of dashed lines for various possibilities. This is mutually exclusive with constant update - pressing one deletes data from the other, perhaps, or maybe disable button.
Need to save a variable which says how many of the rows are real data, then this row is sent to brownian graph so it knows from where to draw dashed line.

brownian motion random walking:
use scipy
best link:
http://www.scipy.org/Cookbook/BrownianMotion
http://en.wikipedia.org/wiki/Geometric_Brownian_motion
http://en.wikipedia.org/wiki/Wiener_process	
also:
http://www.scipy.org/Cookbook/FittingData
c = scipy.random.standard_normal((5,5,5) ?

- WPF graph program - just local, follow Resolver Exchange example. How does li ghaos orig code differ from altered version on resolver exchange? diff and investigate. Then use one or the other as a base - just copy and paste to start with. Should have ability to create new windows, or add new data to current windows (this functionality already in exchange example). But also has option for real time update.
- real time update button should auto clear brownian forecast
- graph windows to include help instructions
- maybe mention my thoughts on benefits of selective timed functions vs recalcualting whole workbook with RecalculateAfter

/////

Next two sheets:
4. Historical futures contracts, including details of how relevant prices of all involved values changed between start and end of contract, and profit made (CU)
5. Historical commdity transports, including details of how relevant prices of all involved values changed between start and end of contract, and profit made (CU)

Thirdly, summary data sets:
6. Summary data on comparative historical record of countries, split into time periods
Drop down to select country
- name of country's currency
in each time period have
- number of and total value of buys
- number and total value of settled futures
- overall outgoings, overall income, overall profit/loss
- number of futures agreed in period
- average diff between futures settled price in period and price they were agreed at
- average value of currency vs USD

7. Summary data for each shipping company, split into time periods
Drop down to select company
- name of company's country, and its currency
For each time period, have:
- number of different ports served
- average quantity per load
- min quantity in a single load
- max quantity in a single load
- av share price (own currency)
- av share price (USD)
- balance at end of period

////

Fourthly, extreme contrivedness:
8. Travelling freighter problem

- read about 
- use Resolver One and MS Solver Foundation
particularly relevant:
http://code.msdn.microsoft.com/solverfoundation
http://blogs.msdn.com/natbr/archive/2009/04/27/solving-traveling-salesman-problems-using-solver-foundation.aspx
http://blogs.msdn.com/natbr/archive/2009/05/07/solver-foundation-tsp-part-ii-directives-solver-plugins-model-libraries.aspx
http://yetanothermathprogrammingconsultant.blogspot.com/2009/02/ms-solver-foundation-gurobi-2.html
http://yetanothermathprogrammingconsultant.blogspot.com/2009/02/tsp-powerset-formulation.html
http://archive.ite.journal.informs.org/Vol7No1/LeeRaffensperger/
http://blogs.msdn.com/lengningliu/archive/2009/11/04/using-solver-foundation-and-plug-in-solvers-in-ironpython.aspx
http://en.wikipedia.org/wiki/Travelling_salesman_problem
http://en.wikipedia.org/wiki/Priority_queue

also:
http://www.amsterdamoptimization.com/msf.html

- doc: represent all shipping lanes between ports as a graph of interconnected nodes, and do a "travelling freighter problem" solution of shortest route for a freighter to visit each port exactly once. provide a diagram on web.

Find the coordinates for all the ports not commented out in sql insert script

///

9. sheet that calls sorting server with various combinations of parameters (diff lists, diff algorithms), doing each one for a large number of iterations, and gets returned data on time taken. for each alg includes avg/min/max creation time and avg/min/max sort time (creation time not always relevant, otherwise 'N/A). Mark winner for each category with red X.
add to uml deployment. 

///

General Resolver things to do:
Possibly some vaguely sensible management (decisions on when to reuse + close) of the db connection?

////

Database stuff (needs adding to both a) UML diagram and b) actual SQL scripts):
- maybe add some views for use by the various processes that need info from database?
- do some normalisation some time after the design has changed a bit, and doc how I carried this out, and doc what normal form the db is in
- make sure indexes, triggers, fks and pks (and their names), and constraints (and their names) match up UML <-> sql and vice versa
- error handling on error being returned on database query

- test data (or maybe just store some real data from system?):
INSERT INTO dbo.FuturesContract
           (TraderID, CommodityID, PortID, Price , Quantity, PurchaseTime, SettlementTime, ActualSetTime)
     VALUES
     ()
GO

INSERT INTO dbo.WarehousedCommodity
           (TraderID, CommodityID, PortID, FuturesContractID, Quantity, PurchasePrice, PurchaseTime, SaleTime, SalePrice, SalePortID)
     VALUES
     ()
GO

INSERT INTO dbo.CommodityTransport
           (ShippingCompanyID, WarehousedCommodityID, DepartureTime, ArrivalTime)
     VALUES
     ()
GO

later SQL stuff:
- Read database management systems chapters 19, 20, 21
- do some database normalisation and tuning, and security management
- faff about with different sorts of indexes etc, maybe also so totally pointless striping, clustering, etc
- doc optimization/tuning
other ideas:
- views
- stored procedures
- faff with permissions and security and security schemas

////

testing:
- unittest only bank can write to db
- make processes do right thing when other processes go down, and have automated tests for all possibilities if differing orders of collapse.
- unittest the algoriths and data structures service
- unittest multiheadqueue
- However multi-thread and multi-process concurrent aspects of program are not suited to normal unit testing frameworks. just write some sort of stress test script - i.e. start loads and loads of processes and look for obvious problems - including crashing and incorrect answers in data. Doc this (inc CV desc)
- database connections should be closed when no longer needed

- use stress test to try to find any bottlenecks that can be optimised away, and if I find any doc this (maybe inc CV desc).
- need to think of some way of checking that servers have not gone out of sync

////

UML diagrams:

Sequence:
- replace sequence diagram with a slightly more complex one with Fateandguess/trader/bank/shipping company, i.e. something along the lines of:

fateandguess gives surplus prediction (with margin of error) to a single trader
trader tells bank it wishes to organise future
predicted surplus time arises, fateandguess includes price of commodity at each port in its broadcast to bank each tick as per usual (also stock prices)
bank enacts futures settlement
bank sends trader warehouseid
trader works out where to sell and tells shipping companies (multiple) of contract to move goods
stuff copied from current seq diagram about multiple acceptances with shippingcompanies
shipping tells bank when goods leave (bank makes money change hands)
shipping tells bank when goods arrive (bank makes money change hands)

and do another very similar diagram except with shortage, not surplus - i.e. instead of futures, trader buys to warehouse

SQL:
- add add spatial stuff, table inheritance stuff, correct trigger names
- once project is finished, make sure it matches up with actual schema
- stuff that should be kept in sync includes: add table inheritance stuff, triggers, constraints
- maybe make currency short name the key, or at least make unique
- rearrange to be more tidy

Deployment view:
- add the correct protocol labels

////

Variation of price of stocks and commodities

http://en.wikipedia.org/wiki/Geometric_Brownian_motion

I think this is right:

a) use the analytic solution of the equation for GBM, which requires an initial value, two constants, the explanatory variable (time) and Wt
b) make Wt a random variable chosen from a normal distribution with mean 0 and standard deviation equal to the tick time

//////

algorithms bit:
following remote methods

CreateStructure()
args: which structure, list
returns: structure id, time taken

Time results from structure()
args: structureid
returns: structure id, time taken

Time results from sort alg()
args: method, list
returns: time taken

DeleteStructure
args: structure id
returns: success or failure

TimeMethod
method 2: 
1. enum of method to use 2. the list 3. whether to return

- using info both in algos book and database book, have an entirely pointless "sorting server" (including on UML diagram, with a note of explanation) that takes a list of numbers as input, and then sorts the list a method of the callers choice:
- merge sort
- quick sort
- quick sort in place
- heap sort
- hash table
- red black tree
- b tree

It has two types of call, one returns the sorted list, the other just returns how long the sort took.

- unit test
- does data contract require I use get/set properties? how exactly does data contract work?

///

doc:

One day the description here, description in index.htm, description on CV, and description in Wolfie will all need to be synced...

credit ppl from readme on web

The name is a nod to book Tai Pan, that is the general point is that there are several large trading houses which ferry various goods very long distances, though actually here the trading houses have been split into two distinct entities, the "Shipping companies" who do the actual transporting of goods, and the "traders" who predict surpluses and shortages in the market and buy and sell goods accordingly.

Mention how threads generally a bad idea, used as an exercise here, but in most real projects there are simpler, more reliable alternatives (i.e. asynchronous network read/writes, likely combined with callbacks for when data has finished sending or receiving, or otherwise combined with manual system of asynchronous acknowledgement messages between clients).

doc how even without 5 second delay in taking contracts for movements off broadcast, the multithreaded nature of system would mean it would be possible for two threads to simultaneously accept the same request anyway

- describe use of bank and db as mediator of many interactions in system, mention any other patterns used

shorter version for CV etc:

A C# .NET, SQL Server and Python project written to improve my knowledge of various aspects of computer science and software engineering. A large number of heterogeneous multithreaded C# processes interact with each other by sending and receiving messages via TCP sockets. These processes manipulate data using various algorithms and data structures for producing, sorting and manipulating sequences of numbers. Much of the underlying state of the system is stored in a MS SQL Server instance. A user interface to the system is provided in the form of a Python-based spreadsheet. This is also linked to a C# program for producing WPF graphs, and to Microsoft’s Solver Foundation and SciPy for simplistic mathematical modelling. The project also uses UML, unit testing, source control, etc. Around 160 hours work so far.

some phrases that could go in web doc:

Only one of the processes has database write access, and hence acts as a mediator for many of the interactions.

The front end utilises the spreadsheet/Python "mash up" “Resolver One” to provide analysis of the real time data from the database. The Python spreadsheet uses Microsoft's Solver Foundation to solve a version of the Travelling Salesman Problem, and scipy to provide xxx fixme for some of the stochastic outputs of the system. A local C# program is called by the spreadsheet script to produce realtime WPF graphs on same aspects of this analysis.

One final, especially contrived C# service provides an RPC-style interface that takes a list of unsorted numbers and returns the list in alphabetical order. Arguments provided by the caller specify which of a wide variety of differing algorithms or data structures should be used to perform the sorting. blah blah spreadsheet integ

I created a number of UML diagrams to describe various aspects of the system. Some sections of the system are covered by unit tests, but much of the interaction between multiple threads and processes is not suited to this and is merely stress-tested. As with all projects I have worked on since around 2004 (commercial and non-commercial), the source is under version control (in this case git).

- talk about real time graphs on web
- add Solver Foundation to web doc
- lots of xmlcomments for classes and methods (methods only necessary for public classes)
- triggers, constraints, (views?), etc
- web doc spatial database data - though utterly trivial use of spatial data because the database is not used to perform any operations on that data
- scipy
- solver foundation, travelling salesman
- relational algebra/calculus
- time spent graph (note on first point saying includes several weeks in one point)
- cursors within sql
- talk about how peer-to-peer would make far more sense for most of the communication, but I didn't want to spend all my time working soley on efficient network communication and neglect the other parts of the system



