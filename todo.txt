todo now:
- work through comp_study_plan.txt

concurrency now:
- service which continuously broadcasts contents of a queue of simple structs


sql now:
- set correct roles for taipan-r and taipan-rw
- a SQL script which dumps and then recreates database schema
- a SQL script which creates some SQL test data
- util methods to connect to, disconnect from, and possibly query and/or update db
- add database connection strings to some sort of config file

///

Overall plan: lots of C# processes representing entities in a trading economy communicate with each other via XML, some as servers, some as clients, some as both. Most state is contained within a SQL server database, and only one of the processes (the "Bank", the name being a nod to Monopoly). The name is a nod to book Tai Pan, that is the general point is that there are several large trading houses which ferry various goods very long distances, though actually here the trading houses have been split into two distinct entities, the "Shipping companies" who do the actual transporting of goods, and the "traders" who predict surpluses and shortages in the market and buy and sell goods accordingly.
One day the description here, description in index.htm, description on CV, and description in Wolfie will all need to be synced...

Though some of this should be configurable, a reasonable ball park figure might be that we want to have running 30 Public Companies, 10 Shipping Companies, 5 Traders, 1 FateAndGuesswork, 1 FXService, 1 Bank, 1 WPFView, 1 SQL Server instance.

GenericServer
Class that acts as generic server, any project which acts as a server has an instance of this class, which it can configure as to what information to broadcast and when
Logs messages to console and optionally to file

GenericClient
Class that acts as generic client that polls servers, any project which acts as a client has an instance of this class, which it can configure as to what information to broadcast and when
Logs messages to console and optionally to file

GenericSQLReader
Class that acts as a generic read-only interface to the database, any project which reads from db has an instance of this class, which it can configure as to what information to read

GenericSQLReadWriter
Derived from: GenericSQLReader
Class that acts as a generic read/write interface to the database, any project which reads and writes to db has an instance of this class, which it can configure as to what information to read

EconomicPlayer:
Maybe a base class for most of the projects? But maybe not needed. Could have e.g. shared ability to start up from command line and enter a main loop that exits on control-c. Might have a bunch of utility methods.

LibUtil:
Library of utility methods?

DomesticCompany
Servers it polls for input as client:
1. FateAndGuesswork: it discovers when it will have a shortage or surplus of a given commodity, and at what price it will be wish to buy/sell to make up for this
Information it broadcasts as server: that is has a shortage/surplus of a given commodity, and the price at wish it wishes to buy/sell to make up for this
Things it calculates:
Things it reads from database:
Things it writes to database: nothing

Trader
Servers it polls for input as client:
1. FateAndGuesswork for predicted future prices
2. DomesticCompany declarations of shortage
Information it broadcasts as server:
1. decisions to buy goods at a given port, and decisions to organise a futures contract
2. Contracts for movement of goods (from, to, expires)
3. Acceptances and denials of contracts for movement of goods (to shipping companies)
4. Decision to sell warehoused goods
Things it calculates:
1. On basis of distance between ports and also predicted information on future shortage or surplus of a given commodity for a given company, they calculate the most profitable places to buy goods to warehouse in readiness to sell (i.e. somewhere nearby to and cheap for predicted future shortage, possibly the same port), or to organise a futures contract to buy goods in future in readiness to buy (i.e. at the actual port of the predicted future surplus). Then when price fluctuation actually happens, warehoused goods are sold to nearest place that has a demand for those goods, or otherwise futures contract is fufilled and goods are again sold in most profitable way possible. Though unforseen variation and/or the error in the prediction by fate and guesswork could still lead to them losing money.
2. Between contract for movement of goods being accepted and the contract being removed from broadcast, there is a 10 second delay (represents e.g. finalizing negociations). Therefore has to maintain locks on open contracts for movement of goods.
Things it reads from database: distance between ports, which ports import/export a given commodity
Things it writes to database: none

ShippingCompany
Servers it polls for input as client:
1. Available contracts for movement of goods from traders
2. Whether acceptance of movement of goods has been confirmed
Information it broadcasts as server:
1. Acceptance of contract to move goods
2. when it has collected goods, when it has delivered goods. Once bank confirms receipt of message, sent info can be removed from broadcast. See "Trade" database entity for attributes to broadcast.
Things it calculates:
Things it reads from database:
Things it writes to database:
Things it edits in database:

FXService
Information it broadcasts as server: fluctuating currency prices
Things it calculates: fluctuating currency prices via GBM

Bank:
Servers it polls for input as client:
1. FX Server for FX prices. Updated currency value then written to database.
2. Shipping company departures and arrivals. On departure money is debited from trader and credited to both shipping company and seller, on basis of distance of journey. On arrival money is debited from buying company and credited to trader.
3. FateAndGuesswork market prices. Commodity prices in database are updated accordingly.
4. FateAndGuesswork stock prices. Database updated accordingly
5. trader decisions to buy goods to warehouse or to organise a futures contract. db updated accordingly.
6. domestic company declarations of shortage/surplus
7. trader decisions to sell warehoused goods
Information it broadcasts as server: none
Things it calculates:
1. whenever updating bank balances after an economic transaction, if movement it applies modifier from distance (= greater profit to freighter company, greater expense to trader), if trade in goods on open market takes into account current commodity price, if different currencies applies current FX multiplier
2. carries out futures contracts at point in time specified
3. sells warehoused goods at point traders decide to do so

Things it reads from database: nothing
Things it writes to database: see above

FateAndGuesswork
Servers it polls for input as client: none
Information it broadcasts as server:
Four different broadcasts. Firstly, calculated future shortages or surpluses of a given commodity for a given company are broadcast (note only companies_with_location which actually import/export a given commodity will ever produce a surplus/suffer shortage). These are broadcast on two channels: 
a) Guesswork, with an added degree of error, is for Traders to pick up. The next Trader to poll FateAndGuesswork is given the information, and this information is then removed from the queue. two, without any error
b) Fate, it will also broadcast this same information, but without any error, to be picked up by the PublicCompanies. Once received this too is removed from the queue.
Furthermore, there is:
c) Current market price of all commodities. Goes up and down via GBM. Make sure places which neither import nor export a commodity have a price created (unit test this, also take account of this in GUI)
d) Stock prices of each company. Goes up and down via GBM.
Things it calculates:
Semi-randomly calculates which PublicCompanies will in future have a) have surplus of a commodity or b) have shortage of a commodity, of how much quantity (though never more than can fit in one freighter), and at what price they will wish to buy/sell above/below market to make up for this. Primary sector companies more usually have goods available for sale, service sector usually have requests for goods to buy, manufacturing sector more a mixture of the two
Things it reads from database:
Things it writes to database: none
Things it edits in database:

ResolverView
a) able to view constantly updated real time data from the database
b) able to view some statistics and charts built using more complex SQL queries.
For instance:i) both turnover and profit over any given time period for any given economic actor
ii) charts of time vs price for commodoties and stocks

////

Database stuff not currently accounted for in UML diagram:

- For all tables with historical values, have the current value updated via a trigger linked to a new record being inserted into the main table
- maybe constraint on linking ports + commodities + prices: every commodity for every port must appear in link table, no null values allowed for either FK
- some commodities: steel, paper, electronics, cereal, textiles, oil, opium, precious gems, look on wikipedia for main exports of various countries
- constraints to ensure CompanyType is correctly enforced and instances can be neither multiple base classes nor multiple sub classes
- same with PublicCompanyType

- maybe add some views for use by the various processes that need info from database?

- do some normalisation some time after the design has changed a bit, and doc how I carried this out, and doc what normal form the db is in
- tuning/optimisation - faff about with different sorts of indexes etc, maybe also so totally pointless striping, clustering, etc

////

Unit Testing/concurrency testing:
- Database interaction and calculations based on database data well suited to unit testing, do these parts via TDD (and doc this fact). However multi-process concurrent aspects of program are not naturally suited to standard unit testing frameworks. There surely are recognised ways for automated testing of multi-process concurrent programs, and I may add such a system in future, but there are only so many things you can do at once.
- taipan-r cannot write to db

for testing concurrent aspects between different processes, should have a text file of manual checks. Like, an extrapolated version of:
- if any one server goes down, can other servers cope as well as can possibly be expected?
- can different servers get out of sync?
- if one server goes down and then comes back up again, can information accidentally be lost in the crash?

////

UML diagrams:

SQL:
- add constraints

Communication view:
- it should have title "Tai-Pan: ????"
- should be much the same as the deployment view, except without repeating the things there can be multiple of, and it should show which directions each communication can go in, and briefly describe the data transferred by each link

Deployment view:
- add the correct protocol labels
- there need to be more communication links

Also:
a UML diagram for internal working of FateAndGuesswork - showing threads and data created and served by them

////

Variation of price of stocks and commodities

http://en.wikipedia.org/wiki/Geometric_Brownian_motion

I think this is right:

a) use the analytic solution of the equation for GBM, which requires an initial value, two constants, the explanatory variable (time) and Wt
b) make Wt a random variable chosen from a normal distribution with mean 0 and standard deviation equal to the tick time

//////

Concurrency:

choose WCF protocol and doc + put on UML diagram

////

Keeping track of time:

prior to 12 Feb: 20
12-19: 8
20-24 Feb: 20
25-27: 15
28: 3
1: 3
mar 31: 2


