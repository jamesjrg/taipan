<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html>
<head>

<title>Tai-Pan</title>
<meta http-equiv="content-type" content="text/html;charset=iso-8859-1">

<style type="text/css">
body {
    font: 100% Sans-serif;
    background-color: #FFFFFF;
}

div.wrapper {
    background-color: #D2DEFF;
    width: 80%;
    padding:20px;
    margin: 40px auto 40px auto;

    /* I'm sure IE users will still live without http://github.com/malsup/corner */
    -webkit-border-radius: 20px;
    -moz-border-radius: 20px;
    border-radius: 20px;
}

img {
    display: block;
    margin-left: auto;
    margin-right: auto;
    border: 20px solid #D2DEFF;
}
</style>

</head>

<body>

<div class="wrapper">
<h2>Tai-Pan</h2>

<h3>Introduction</h3>

<p>"Tai-Pan" is a small project written to learn a bit more about .NET, SQL Server, and computer science. The backend is written in C# and SQL. The front end is written in IronPython for the Resolver One spreadsheet program. It features a large number of heterogeneous, multithreaded processes, most interacting via TCP sockets. The underlying state of the system is stored in a MS SQL Server instance. Various data structures and algorithms are implemented, though not all are required by the underlying system - e.g. B-Trees, hash tables, and numerous sorting algorithms. I also made basic use of Microsoft Solver Foundation (a mathematical modelling framework).</p>

<p>This web page provides an outline of the project, divided into the following sections:</p>
<ul>
<li><a href="#heng">Software Engineering</a></li>
<li><a href="#hsql">Relational databases</a></li>
<li><a href="#hconcurrency">Concurrency and distributed systems</a></li>
<li><a href="#hmath">Simple mathematics and algorithmics</a></li>
<li><a href="#hlinks">Links (including source code)</a></li>
</ul>
</p>

</div>

<div class="wrapper">
<h3 id="heng">Software Engineering</h3>

<p><img src="images/Deployment.png"/></p>

<p>The system is seperated into several different processes.</p>

<p>With the exception of "AlgoServer", all of the processes interact as a single system. AlgoServer is an extremely contrived service which was mostly written as an exercise in learning more about various sorting algorithms and complex ordered structures (see <a href="#hmath">math section</a>).</p>

<p>The system makes use of various design patterns both within each process and in the system as a whole. Patterns seen in system as a whole include the n-tier division of data, logic and view (the SQL Server instance, C# processes, and IronPython spreadsheet), and the use of the Bank as a mediator to the database (no other process has write access, leaving the Bank process to manage the stored state of the system).</p>

<p>Near the beginning of the design process I created several UML diagrams describing various aspects of the system (as can be seen on this webpage). I have written unit tests against sections of the code to make the system more reliable. As with all projects I have worked on since 2004 (commercial and non-commercial), the source is under version control (in this case git). See the <a href="#hlinks">links section</a> for a link to browse the repository.</p>
</div>

<div class="wrapper">
<h3 id="hsql">Relational databases</h3>

<p>The following diagram is rather messy, but the project was written to learn more about .NET, SQL Server and algorithmics, not to learn how to create beautiful UML diagrams:</p>

<p><img src="images/DB Schema.png"/></p>

<p>"ShippingCompany" and "Trader" are subtypes of "Company". The "CompanyType" relation, along with several foreign key constraints, exists to enforce the rule that all "Company" relations must have one and only one matching relation in either "ShippingCompany" or "Trader" without the need for check constraints.</p>

<p>With the exception of tables storing historic data, all attributes are atomic, no non-prime attributes are functionally determined by only part of a candidate key, no non-prime attributes are transitively dependent on a candidate key, and every determinant is a key. As such almost all relations are in Boyce-Codd normal form. The most recent row in each of the four tables of historical data duplicates a value from elsewhere in the database, and so the schema features some denormalization in order to remove the need for quite so many joins when performing queries. The C# code calls a SQL stored procedure whenever an insert statement is peformed on a relevant table to ensure the historical data is also updated; an alternative would have been to define relevant triggers.</p>

<p>As well as stored procedures, I have also made some use of user defined functions, cursors, and SQL Server's spatial geography data type. I have given some basic thought to security and permissions - there are seperate read-only and read-write logins, and processes only use the read-write login where necessary - but complex permissions, views and security schemas would seem rather too contrived for a project being developed and run by a single person.</p>

<p>I have given some thought to indexes and efficiency, but the project is not large or complex enough to provide much scope for index tuning, execution plan analysis analysis, etc.</p>
</p>
</div>

<div class="wrapper">
<h3 id="hconcurrency">Concurrency and distributed systems</h3>

<p>Most of the processes communicate via relatively low-level TCP sockets, though rather than writing my own application-level protocol I am for the most part simply using C#'s XML serialization and deserialization facilities to turn data into strings suitable for writing to a network stream. Some TCP connections consist of one server communicating with multiple peers, whilst others are simply peer-to-peer.</p>

<p>Unlike the other processes, AlgoServer functions as a SOAP web service, and was built using WCF (Windows Communication Foundation). The spreadsheet connects to this via a small auto-generated proxy assembly.</p>

<p>The processes communicate entirely via asynchronous, fire and forget messages. Many of the messages are either a continuous broadcast or otherwise do not require a reply, and hence for the most part this approach is the correct one to take. The interaction between traders and shipping companies involves an exchange of several messages linked together, and so would ideally be better suited to using a system of callbacks than continous polling. I have previously had a small amount of experience working with event-driven networking with Python (Twisted) and Javascript (MochiKit and AJAX).</p>

<p>The processes are themselves multithreaded, and so have to pay some attention to sharing data between threads in a safe manner, though the processes are sufficiently small that this was not a major undertaking. Data shared between threads is stored in instances of a synchronised, multi-headed queue structure, whereby the queue maintains a seperate head index for each subscribing thread.</p>

<p>Below is a sequence diagram showing the network messaging sent as a result of a Trader receiving a forecast of a surplus of a given commodity at a given port at some point in the future. A real system would likely have more acknowledgement messages and error checking, but I have kept things fairly simple:</p>

<p><img src="images/SequenceSurplus.png"/></p>

<p>If a trader receives a message indicating a predicted future shortage of a commodity at a port, a similar flow of actions results as for a predicted surplus:</p>

<p><img src="images/SequenceShortage.png"/></p>
</div>

<div class="wrapper">
<h3 id="hmath">Simple mathematics and algorithmics</h3>

<p>A user interface to the system is provided in the form of an IronPython-based spreadsheet using "Resolver One", billed as a "programable spreadsheet" or as a "mash-up of a spreadsheet and an IDE". Rather than having a strict divide between macros and the spreadsheet itself (as in Excel), in Resolver One IronPython scripting is closely integrated into the program. It also allows for loading external .NET or Python libraries, and for creating a limited GUI by adding clickable buttons and drop downs to cells.</p>

<p>Several tabbed spreadsheets are used as a front end to view the data being fed into the SQL Server database by the backend C# processes.</p>

<p>Various data structures and algorithms which are not needed by the main backend system - B-Trees, hash tables, and numerous sorting algorithms - can also be run and manipulated by the spreadsheet front end. Basic use is also made of Microsoft Solver Foundation (a mathematical modelling framework) to solve a version of the Travelling Salesman Problem. </p>

<p><img src="images/gbm.png"/></p>

<p><img src="images/TFP.png"/></p>

<p><img src="images/tfp_result.png"/></p>

<p><img src="images/sorting.png"/></p>
</div>

<div class="wrapper">
<h3 id="hlinks">Links (including source code)</h3>

<p>The source repository for the project is at <a href="http://github.com/jamesjrg/taipan">http://github.com/jamesjrg/taipan</a>.</p>
</div>

</body>
</html>
