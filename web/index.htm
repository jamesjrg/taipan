<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html>
<head>

<title>Tai-Pan</title>
<meta http-equiv="content-type" content="text/html;charset=iso-8859-1">

<style type="text/css">
body {font: 100% Sans-serif; background-color: #FFFFFF;}
div.wrapper {font: 100% Sans-serif; background-color: #D2DEFF; width: 94%; padding:20px; margin: 40px auto 40px auto;}
</style>

</head>

<body>

<div class="wrapper">
<h2>Tai-Pan</h2>

<h3>Introduction</h3>

<p>"Tai-Pan" is a C# .NET, SQL Server and Python project written to improve my knowledge of various aspects of computer science and software engineering. A large number of heterogeneous, multithreaded C# processes interact with each other via TCP sockets. Much of the underlying state of the system is stored in a MS SQL Server instance. The system includes implementations of various data structures and algorithms (e.g. B-Trees, hash tables, numerous sorting algorithms, a couple of probability distributions). A user interface to the system is provided in the form of an IronPython-based spreadsheet that a) makes queries on both the database and on a C# SOAP web service a) makes queries on both the database and on a C# SOAP web service b) loads a C# WPF assembly to produce interactive graphs of the summary data and c) utilises a mathematical optimization framework to solve a simple linear programming problem. The project also makes use of UML, unit testing, Git, etc. </p>

<p>This web page provides an outline of the project, divided into the following sections:</p>
<ul>
<li><a href="#heng">Software Engineering</a></li>
<li><a href="#hsql">Relational databases</a></li>
<li><a href="#hconcurrency">Concurrency and distributed systems</a></li>
<li><a href="#hmath">Mathematics and algorithmics</a></li>
<li><a href="#hlinks">Links (including source code)</a></li>
</ul>
</p>

<p>&nbsp;</p>

<h3 id="heng">Software Engineering</h3>

<p><img src="images/Deployment.png"/></p>

<p>The system is seperated into several different processes, and some of these processes have multiple copies running at once. Though in the above deployment diagram each process is running on a different node, in reality I test the program by having all the processes running on a single computer and communicating via localhost.</p>

<p>With the exception of "AlgoServer", all of the processes interact as a single system. AlgoServer is an extremely contrived service which was mostly written as an exercise in learning more about various sorting algorithms and complex ordered structures (see <a href="#hmath">math section</a>).</p>

<p>The system makes use of various design patterns both within each process and in the system as a whole. Patterns seen in system as a whole include the n-tier division of data, logic and view (the SQL Server instance, C# processes, and IronPython spreadsheet), and the use of the Bank as a mediator to the database (no other process has write access, leaving the Bank process to manage the stored state of the system).</p>

<p>I used various standard software engineering techniques in the design and construction of the system. Near the beginning of the design process I created several UML diagrams describing various aspects of the system. I have written unit tests against sections of the code to make the system more reliable. As with all projects I have worked on since 2004 (commercial and non-commercial), the source is under version control (in this case git). See the <a href="#hlinks">links section</a> for a link to browse the repository.</p>

<p>There are some things I could have done but didn't due to lack of time. I could have put more focus on unit testing - either by working via test driven development, or at least by having a far high coverage of unit tests. However, most of the system logic is concurrent, spread across multiple processes, and often also stochastic, and hence not suited to unit testing at all. Meanwhile the user interface is sufficiently simple that unit testing isn't really necessary. The multi-process, concurrent aspects of the system which cannot be unit tested would ideally instead be stress tested with a series of automated scripts, but I have not currently built such a test system.</p>

<p>&nbsp;</p>

<h3 id="hsql">Relational databases</h3>

<p><img src="images/DB Schema.png"/></p>

<p>The tangle of foreign key arrows here is a total mess, possibly I should do something to make the diagram more readable, but nevermind. The schema also includes numerous integrity constraints and indexes which are not shown in this diagram.</p>

<p>Within individual tables there are no repeating groups, no non-prime attributes that are functionally determined by only part of a candidate key, no non-prime attributes transitively dependent on a candidate key, and no prime attributes functionally determined by a proper subset of a candidate key. As such the schema is in Boyce-Codd normal form.</p>

<p>Around the top left of the diagram are the classes which hold entries for the economic players represented as C# processes - Company, Trader, and ShippingCompany. "Company" is a base table for "Public Company" and for "Trader", with "inheritance" controlled by CompanyType and a series of constraints.</p>

<p>Along the top are four tables containing historical data on various prices and balances. Originally a trigger updated the relevant tables whenever records were inserted into these tables, though SQL Server's lack of a FOR EACH ROW trigger means I have switched to using stored procedures.</p>

<p>The rest of the schema is made of tables which represent various aspects of the modelled system - countries, ports, futures contracts, commodities, etc.</p>

<p>The locations of the ports are stored using SQL Server's geography data type, this is used in various places to calculate distances between ports.</p>

<p>The vast majority of data manipulation is performed in C# and Python, but the database does make some minor usage of stored procedures and cursors.</p>

<p>I have given some basic thought to security and permissions - there are seperate read-only and read-write logins, and processes only use the read-write login where necessary - but complex permissions, views and security schemas would seem rather too contrived for a project being developed and run by a single person.</p>

<p>I have given some slight thought to indexes and efficiency, but I have not yet put any effort into index tuning, execution plan analysis analysis, etc.</p>
</p>

<p>&nbsp;</p>

<h3 id="hconcurrency">Concurrency and distributed systems</h3>

<p>Most of the processes communicate via relatively low-level TCP sockets, though rather than writing my own application-level protocol I am for the most part simply using C#'s XML serialization and deserialization facilities to turn data into strings suitable for writing to a network stream. Some TCP connections consist of one server communicating with multiple peers, whilst others are simply peer-to-peer.</p>

<p>AlgoServer is built using WCF (Windows Communication Foundation), which largely automates the process of making a server with methods available as a SOAP web service.</p>

<p>The processes communicate entirely via asynchronous, fire and forget messages. Many of the messages are either a continuous broadcast or otherwise do not require a reply, and hence for the most part this approach is the correct one to take. The interaction between traders and shipping companies involves an exchange of several messages linked together, and so would be better suited to using a system of callbacks than continous polling, but I have thus far focused more on other aspects of the system. I have perviously had a small amount of experience working with event-driven networking with Python (Twisted) and Javascript (MochiKit and AJAX).</p>

<p>The processes are themselves multithreaded, and so have to pay some attention to sharing data between threads in a safe manner, though the processes are sufficiently small that this was not a major undertaking. Data shared between threads is stored in instances of a custom synchronised, multi-headed queue structure, whereby the queue maintains a seperate head index for each subscribing thread.</p>

<p>FOLLOWING SECTION FLAGRANTLY A WORK IN PROGRESS:</p>

<p>blah blah explanation of following diagram. blah blah contract for movements of goods and locking process</p> </p>blah blah real system would likely have more acknowledgement messages and error checking, but this would make things unnecessarily messy for the purposes of the exercise.</p>

<p><img src="images/SequenceSurplus.png"/></p>

<p>If a Trader receives a message indicating a predicted future shortage of a commodity at a port, a similar flow of actions results as for a predicted surplus:</p>

<p><img src="images/SequenceShortage.png"/></p>

<p>&nbsp;</p>

<h3 id="hmath">Mathematics and algorithmics</h3>

<p>A user interface to the system is provided in the form of an IronPython-based spreadsheet using a spreadsheet program called "Resolver One", billed as a "programable spreadsheet" or as a "mash-up of a spreadsheet and an IDE". Rather than allowing macros to be run against the spreadsheet in a limited fashion (as with Excel), in Resolver One the entire sheet is an IronPython script that you are free to modify. It is extremely flexible - you can load external .NET or Python libraries and write code utilising them to manipulate the cells in the workbook, and you can also add clickable buttons and drop downs to cells for user interaction.</p>

<p><img src="images/gbm.png"/></p>

<p>There are various prices and values that fluctuate in the model. These include commodity prices at each port (which generally follow Geometric Brownian Motion but are subject to random price jumps), FX rates (entirely determined by Geometric Brownian Motion), share prices (entirely determined by Geometric Brownian Motion), and bank balances (determined by the interactions between the various players in the system). The IronPython spreadsheet code adds buttons to fetch the most recent commodity prices or FX rates from the database, buttons to optionally create predicted future random walk data points, and buttons to graph this data by instantiating a WPF graph window from a .NET assembly (the WPF chart code being almost entirely the public domain work of other people).</p>

<p>The GBM sequences are produced using a tiny custom class library written in C# and shared by both the processes in the main system and the IronPython spreadsheet code. This library provides functions for Gaussian and Geometric Brownian sequences, the first based on the Box-Muller transformation, the latter based on sampling the former.</p>

<p>The WPF chart assembly loaded by the spreadsheet (and the IronPython code that instantiates its window) is almost entirely the public domain work of other people. I spent a little while working on some minor modifications to the graph, but it turned out that the small modifications I wished to make would have required a major rewrite of the code, so I have put that idea on hold.</p>

<p>FOLLOWING SECTION FLAGRANTLY A WORK IN PROGRESS:</p>

<p>[screenshot of summary sheet]</p>

<p>blah blah then five sheets of summary data produced via SQL queries - first two sheets have pretty simple queries, next three sheets have slightly more complex queries which aggregate statistics on various sorts of activity, grouped into time periods.</p>

<p><img src="images/TFP.png"/></p>

<p>[screenshot of TFP result page]</p>

<p>blah blah Travelling Salesman Problem -> travelling freighter problem solution of shortest route for a freighter to visit each port exactly once, MS Solver Foundation, linear programming and constraints as a possible way to deal with TSP, mention TUI</p>. blah blah started off reading about linear prgoramming and TSP, then took C# code from a blog post that used Solver to solve it, then converted it to Python. next step is to not use some predefined data but instead use the spatial data from the database on the locations of the various ports in the db, and to provide dropdowns on the spreadsheets to select which ports are to be included in the tour. This is actually somewhat ridiculous as it assumes ships can travel in straight arcs from any two ports, without land getting in the way, but anyway. The step after that will be to modify the problem to match up better with the supposed real world that the system models - e.g. to disallow certain arcs which involve travelling directly over large land masses, but allowing optional stop overs at certain ports and allow visiting ports more than once. Alternatively, I could add costs and benefits to certain arcs representing the different profits and losses to be made by fufilling freight movement contracts on those shipping routes.</p>

<p>[screenshot of alg timing sheet]</p>

<p>AlgoServer provides implementations of various complex data structures and sorting algorithms: insertion sort, merge sort, heap sort, quick sort, randomized quick sort. counting sort, chained hash map, binary search tree, red-black tree, B-tree. These methods can be called as a SOAP web service. The sorting methods return both the sorted data and the amount of time the algorithm took on the server. blah blah sheet makes lots of calls to test sorting algs. blah stats on their av/min/max time taken.</p>

<p>On calling the web service to create a data structure the caller is returned an ID which can the client can then include as a parameter when requesting operations to be made on that data structure (e.g. search, insert, remove), or to delete it. However, these methods are not currently utilised by the spreadsheet.</p>

<h3 id="hlinks">Links (including source code)</h3>

<p>The repository for the project is at <a href="http://github.com/jamesjrg/taipan">http://github.com/jamesjrg/taipan</a>.</p>

<p>A database of all the projects I have ever worked on is available at <a href="http://www.jameswritesstuff.co.uk/sde/">http://www.jameswritesstuff.co.uk/sde/</a>.</p>

</div>
</body>
</html>
