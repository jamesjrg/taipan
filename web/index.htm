<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html>
<head>

<title>Tai-Pan</title>
<meta http-equiv="content-type" content="text/html;charset=iso-8859-1">

<style type="text/css">
body {font: 100% Sans-serif; background-color: #FFFFFF;}
div.wrapper {font: 100% Sans-serif; background-color: #D2DEFF; width: 94%; padding:20px; margin: 40px auto 40px auto;}
</style>

</head>

<body>

<div class="wrapper">
<h2>Tai-Pan</h2>

<h3>Introduction</h3>

<p>"Tai-Pan" is a C# .NET, SQL Server and Python project written to improve my knowledge of various aspects of computer science and software engineering. A large number of heterogeneous, multithreaded C# processes interact with each other via TCP sockets. Much of the underlying state of the system is stored in a MS SQL Server instance. The system includes implementations of various data structures and algorithms (e.g. B-Trees, hash tables, numerous sorting algorithms, a couple of probability distributions). A user interface to the system is provided in the form of an IronPython-based spreadsheet that a) makes numerous queries on both the database and on a C# SOAP web service b) loads a C# WPF assembly to produce interactive graphs of the summary data and c) utilises a mathematical optimization framework to solve a linear programming problem, using data from the rest of the system. The project also makes use of UML, unit testing, Git, etc.</p>

<p>This web page provides an outline of the project, divided into the following sections:</p>
<ul>
<li><a href="#heng">Software Engineering</a></li>
<li><a href="#hsql">Relational databases</a></li>
<li><a href="#hconcurrency">Concurrency and distributed systems</a></li>
<li><a href="#hmath">Mathematics and algorithmics</a></li>
<li><a href="#hlinks">Links (including source code)</a></li>
</ul>
</p>

<p>&nbsp;</p>

<h3 id="heng">Software Engineering</h3>

<p><img src="images/Deployment.png"/></p>

<p>The system is seperated into several different processes, and some of these processes have multiple copies running at once. Though in the above deployment diagram each process is running on a different node, in reality I test the program by having all the processes running on a single computer and communicating via localhost.</p>

<p>With the exception of "AlgoServer", all of the processes interact as a single system. AlgoServer is an extremely contrived service which was mostly written as an exercise in learning more about various sorting algorithms and complex ordered structures (see <a href="#hmath">math section</a>).</p>

<p>The system makes use of various design patterns both within each process and in the system as a whole. Patterns seen in system as a whole include the n-tier division of data, logic and view (the SQL Server instance, C# processes, and IronPython spreadsheet), and the use of the Bank as a mediator to the database (no other process has write access, leaving the Bank process to manage the stored state of the system).</p>

<p>I used various standard software engineering techniques in the design and construction of the system. Near the beginning of the design process I created several UML diagrams describing various aspects of the system. I have written unit tests against sections of the code to make the system more reliable. As with all projects I have worked on since 2004 (commercial and non-commercial), the source is under version control (in this case git). See the <a href="#hlinks">links section</a> for a link to browse the repository.</p>

<p>There are some things I could have done but didn't due to lack of time. I could have put more focus on unit testing - either by working via test driven development, or at least by having a far high coverage of unit tests. However, most of the system logic is concurrent, spread across multiple processes, and often also stochastic, and hence not suited to unit testing at all. Meanwhile the user interface is sufficiently simple that unit testing isn't really necessary. The multi-process, concurrent aspects of the system which cannot be unit tested would ideally instead be stress tested with a series of automated scripts, but I have not currently built such a test system.</p>

<p>&nbsp;</p>

<h3 id="hsql">Relational databases</h3>

<p><img src="images/DB Schema.png"/></p>

<p>The tangle of foreign key arrows here is a total mess, possibly I should do something to make the diagram more readable, but nevermind. The schema also includes numerous integrity constraints and indexes which are not shown in this diagram.</p>

<p>Within individual tables there are no repeating groups, no non-prime attributes that are functionally determined by only part of a candidate key, no non-prime attributes transitively dependent on a candidate key, and no prime attributes functionally determined by a proper subset of a candidate key. As such the schema is in Boyce-Codd normal form.</p>

<p>Around the top left of the diagram are the classes which hold entries for the economic players represented as C# processes - Company, Trader, and ShippingCompany. "Company" is a base table for "Public Company" and for "Trader", with "inheritance" controlled by CompanyType and a series of constraints.</p>

<p>Along the top are four tables containing historical data on various prices and balances. Originally a trigger updated the relevant tables whenever records were inserted into these tables, though SQL Server's lack of a FOR EACH ROW trigger means I have switched to using stored procedures.</p>

<p>The rest of the schema is made of tables which represent various aspects of the modelled system - countries, ports, futures contracts, commodities, etc.</p>

<p>The locations of the ports are stored using SQL Server's geography data type, this is used in various places to calculate distances between ports.</p>

<p>The vast majority of data manipulation is performed in C# and Python, but the database does make some usage of stored procedures, user defined functions, and cursors.</p>

<p>I have given some basic thought to security and permissions - there are seperate read-only and read-write logins, and processes only use the read-write login where necessary - but complex permissions, views and security schemas would seem rather too contrived for a project being developed and run by a single person.</p>

<p>I have given some slight thought to indexes and efficiency, but I have not yet put any effort into index tuning, execution plan analysis analysis, etc.</p>
</p>

<p>&nbsp;</p>

<h3 id="hconcurrency">Concurrency and distributed systems</h3>

<p>Most of the processes communicate via relatively low-level TCP sockets, though rather than writing my own application-level protocol I am for the most part simply using C#'s XML serialization and deserialization facilities to turn data into strings suitable for writing to a network stream. Some TCP connections consist of one server communicating with multiple peers, whilst others are simply peer-to-peer.</p>

<p>AlgoServer is built using WCF (Windows Communication Foundation), which largely automates the process of making a server with methods available as a SOAP web service.</p>

<p>The processes communicate entirely via asynchronous, fire and forget messages. Many of the messages are either a continuous broadcast or otherwise do not require a reply, and hence for the most part this approach is the correct one to take. The interaction between traders and shipping companies involves an exchange of several messages linked together, and so would ideally be better suited to using a system of callbacks than continous polling. I have previously had a small amount of experience working with event-driven networking with Python (Twisted) and Javascript (MochiKit and AJAX).</p>

<p>The processes are themselves multithreaded, and so have to pay some attention to sharing data between threads in a safe manner, though the processes are sufficiently small that this was not a major undertaking. Data shared between threads is stored in instances of a synchronised, multi-headed queue structure, whereby the queue maintains a seperate head index for each subscribing thread.</p>

<p>Below is a sequence diagram showing the network messaging sent as a result of a Trader receiving a forecast of a surplus of a given commodity at a given port at some point in the future. A real system would likely have more acknowledgement messages and error checking, but I have kept things fairly simple:</p>

<p><img src="images/SequenceSurplus.png"/></p>

<p>If a trader receives a message indicating a predicted future shortage of a commodity at a port, a similar flow of actions results as for a predicted surplus:</p>

<p><img src="images/SequenceShortage.png"/></p>

<p>&nbsp;</p>

<h3 id="hmath">Mathematics and algorithmics</h3>

<p>A user interface to the system is provided in the form of an IronPython-based spreadsheet using a spreadsheet program called "Resolver One", billed as a "programable spreadsheet" or as a "mash-up of a spreadsheet and an IDE". Rather than allowing macros to be run against the spreadsheet in a limited fashion (as with Excel), in Resolver One the entire sheet is an IronPython script that you are free to modify. It is extremely flexible - you can load external .NET or Python libraries and write code utilising them to manipulate the cells in the workbook, and you can also add clickable buttons and drop downs to cells for user interaction.</p>

<p><img src="images/gbm.png"/></p>

<p>There are various prices and values that fluctuate in the model. These include commodity prices at each port (which generally follow Geometric Brownian Motion but are subject to random price jumps), FX rates (entirely determined by Geometric Brownian Motion), share prices (entirely determined by Geometric Brownian Motion), and bank balances (determined by the interactions between the various players in the system). The first two sheets of the workbook (the sheets being the various tabs at the bottom of the above screenshot) include buttons to fetch the most recent USD-adjusted commodity prices or FX rates from the database, buttons to optionally create predicted future random walk data points, and buttons to graph this data by instantiating a WPF graph window from a .NET assembly. The WPF chart code is almost entirely the public domain work of other people, with only minor changes.</p>

<p>The GBM sequences are produced using a tiny custom class library written in C# and shared by both the processes in the main system and the IronPython spreadsheet code. This library provides functions for Gaussian and Geometric Brownian sequences, the first based on the Box-Muller transformation, the latter based on sampling the former.</p>

<p>The following six sheets display the results of various SQL queries on the database, aggregating summary data in various ways.</p>

<p>FOLLOWING SECTION FLAGRANTLY A WORK IN PROGRESS:</p>

<p>The next sheet after the "Country Summary" is the "Travelling Freighter Problem", a variation on the classic NP-hard "Travelling Salesman Problem". XXX define orif problem. xxx define my problem - globe rather than flat, maybe some extra constraints too (like ground in way). travelling freighter problem solution of shortest route for a freighter to visit each port exactly once. blah blah here's a diagram:</p>

<p><img src="images/TFP.png"/></p>

<p>[screenshot of TFP result page]</p>

<p>various possible ways to approach TSP. simpel greedy algorithm, edges and vertices graph and miniumum spanning tree, flow solutions. blah blah One way is generic linear programming. blah blah MS Solver Foundation, linear programming and constraints as a possible way to deal with TSP, mention TUI.</p>

<p>blah blah took C# code from a blog post that used Solver to solve it, then converted it to Python. next step is to not use some predefined data but instead use the spatial data from the database on the locations of the various ports in the db, and to provide dropdowns on the spreadsheets to select which ports are to be included in the tour. This is actually somewhat ridiculous as it assumes ships can travel in straight arcs from any two ports, without land getting in the way, but anyway. The step after that will be to modify the problem to match up better with the supposed real world that the system models - e.g. to disallow certain arcs which involve travelling directly over large land masses, but allowing optional stop overs at certain ports and allow visiting ports more than once. Alternatively, I could add costs and benefits to certain arcs representing the different profits and losses to be made by fufilling freight movement contracts on those shipping routes.</p>

<p>[screenshot of alg timing sheet]</p>

<p>AlgoServer implements various complex data structures and sorting algorithms: insertion sort, merge sort, heap sort, quick sort, randomized quick sort. counting sort, chained hash map, binary search tree, red-black tree, B-tree. It provides a SOAP web service with several methods:</p>

<ul>
<li>It provides a method called "TimeSort" which takes a sorting method, an array to be sorted, and a number of iterations to repeat the sorting on the original array. Returned is not only the sorted list, but also the time taken to perform the iterations. The spreadsheet provides dropdowns to select a number of different algorithms, and fields to choose a size of randomized list to create and the number of iterations to perform, and then displays the comparative time that algorithm's iterations took on the randomized list.
</li>
<li>There is a method to create a data structure of given type. On calling this method the server returns an ID which can the client can then include as a parameter when requesting operations to be made on that data structure (e.g. search, insert, remove), or to delete it. However, these methods are not currently utilised by the spreadsheet.</li>
</ul>

<p>&nbsp;</p>

<h3 id="hlinks">Links (including source code)</h3>

<p>The repository for the project is at <a href="http://github.com/jamesjrg/taipan">http://github.com/jamesjrg/taipan</a>.</p>

<p>A database of all the projects I have ever worked on is available at <a href="http://www.jameswritesstuff.co.uk/sde/">http://www.jameswritesstuff.co.uk/sde/</a>.</p>

</div>
</body>
</html>
