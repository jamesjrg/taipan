<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html>
<head>

<title>Tai-Pan</title>
<meta http-equiv="content-type" content="text/html;charset=iso-8859-1">

<style type="text/css">
body {font: 100% Sans-serif; background-color: #FFFFFF;}
div.wrapper {font: 100% Sans-serif; background-color: #D2DEFF; width: 94%; padding:20px; margin: 40px auto 40px auto;}
</style>

</head>

<body>

<div class="wrapper">
<h2>Tai-Pan</h2>

<h3>Introduction</h3>

<p>"Tai-Pan" is a C# .NET project that simulates a trading economy. In order to improve my knowledge of the theory behind relational databases, concurrency, and software engineering, the project was purposefully designed to be fairly complex. As such there are a large number of heterogeneous, multi-threaded client and server processes broadcasting and polling XML messages, whilst simultaneously interacting with a SQL Server database that holds most of the underlying state of the system. The front end makes use of a spreadsheet/Python IDE "mash up" called Resolver One, and consists of Python program that displays constantly updating analysis of the data from the database.</p>

<p>The purpose of this web page is to demonstrate what I learnt. Click one of the headings below to jump to a section which interests you:</p>
<ul>
<li><a href="#heng">Software Engineering (software design, UML, unit testing, source control, etc)</a></li>
<li><a href="#hsql">SQL and SQL Server</a></li>
<li><a href="#hconcurrency">Concurrency and networking</a></li>
<li><a href="#hdotnet">C# and .NET</a></li>
<li><a href="#hpython">Python and the user front-end</a></li>
</ul>
</p>

<p>&nbsp;</p>

<h3 id="heng">Software Engineering</h3>

<p>[UML communication diagram - several processes, XML, SQL, database]</p>

<p>xxx brief explanation of diagram. xxx explain messaging protocol - xml.</p>

<p>blah blah all the processes are enitrely seperate and communicate via [netowork protocol], and so the system is (or at least could be) very distributed. The following deployment diagram demonstrates this:</p>

<p><img src="images/Deployment.png"/></p>

<p>xxx in the concurrency section of this document there is a UML sequence diagram which models in closer detail the communication between the Traders and the DomesticCompanies, and another UML diagram showing the database schema in the SQL section. I haven't exported a class diagram for the C# code because a) it would be very easy to do and so I wouldn't learn anything by doing so and b) due to the distributed nature of the system the class structure for each individual process is actually pretty simple. I have dealt with more complicated class hierarchies on other projects.</p>

<p>xxx blah blah test driven development (Isotoma, concurrency, etc)</p>

<p>For source control I used Git. I have used source control on almost every single software project I have been involved in since 2004, both commercial and non-commercial. I have mostly used SVN and CVS, but for a few recent projects, including this one, I have used Git. I can see how the distributed nature of Git, and it's emphasis on branching and merging, makes it very well suited to distributed open source projects. For projects like this one, with just one developer - or in fact any project which doesn't make substantial use of branching and merging - I'm not convinced Git is any more productive to use than SVN.</p>

<p>The git repository for the project is at <a href="http://github.com/jamesjrg/taipan">http://github.com/jamesjrg/taipan</a></p>

<h3 id="hsql">SQL and SQL Server</h3>

<p><img src="images/DB Schema.png"/></p>

<p>The tangle of foreign key arrows here is a total mess, possibly I should do something to make the diagram more readable, but nevermind.</p>

<p>In the centre of the diagram are some classes which hold entries for the economic players represented as C# processes - Trader, PublicCompany (which includes Shipping Companies) and DomesticCompany. "Company" is a base table for "Public Company" and for "Trader". "Public Company" is in turn a base table for "DomesticCompany". blah blah explanation of diagram.</p>

<p>There are four tables containing historical data on monetary balances and values, each of which uses a trigger to update the current price attribute in the table for which they are recording historical data. xxx therefore there are four redunadntly stored values, as a search of the historical data tables whenever a value or balance was required would be very inefficient. Within individual tables there are no repeating groups, no non-prime attributes that are functionally determined by only part of a candidate key, no non-prime attributes transitively dependent on a candidate key, and no prime attributes functionally determined by a proper subset of a candidate key. As such the schema is in Boyce-Codd normal form.</p>

<p>blah blah stored procedures (briefly toyed with some util sps but found not needed), talk about where I've used before (sde, setanalyser, forkd). blah blah some basic security and permissions - seperate r and rw logins to db, only bank and sql creation scripts use rw. but given there is in reality only one user, myself, complex security permissions schemes applying to different tables, sql views and such like would be complexity even more contrived than the rest of the project.</p>

<p>blah blah blah tuning and efficiency and indexes very large tables</p>

<p>I have just used standard ADO.NET rather than LINQ for various reasons:
<ul>
<li>most of the database queries are actually executed by the Python-based front-end, where LINQ is irrelevant</li>
<li>the project was meant as an exercise to learn about some of the theory of complex software design, not as an exercise in memorising the syntax of a particular object relational mapper</li>
<li>my prior experience of object-relation mappers (in Python) is that they aren't much use for complex queries anyway</li>
</ul>
</p>

<h3 id="hconcurrency">Concurrency and networking</h3>

<p>blah blah concurrency with processes and within processes with threading, blah blah contract for movements of goods and locking process</p>

<p>[UML diagram of locking process]

<p>blah blah explanation of diagram</p>

<p>blah blah in terms of formal testing and guarantees of reliability regarding the concurrent aspects of the system, I have not currently done much serious work. Concurrency is not well suited to normal unit testing, and effectively setting up automated tests of concurrent systems is a very large topic. I may do further reading on this subject in future.</p>

<p>As far as networking efficiency is concerned, here too I have done limited work - I have just let WCF handle the details of network communication. Here too I could do more work in future, though in reality any network code below the application level is generally written in C++ or Java, not C#. blah still, might be nice to build on what I have learnt about networking blah blah mention I have done some slightly complex networking stuff before (blah blah mention Twisted at Isotoma and my threaded Java app and TCP at Opera).</p>

<h3 id="hdotnet">C# and .NET</h3>

<p>[image of some sort of interactive real time data stream]</p>
<p>[image of commodity price variation graph]</p>

<p>blah blah GBM</p>

<p>blah blah compare to C++ and Java and Python</p>

<h3 id="#hpython">Python and the user front-end</h3>

<p>I considered various options for the user front end. I wanted to display and analyse large amounts of real time data, with the possibility of creating pretty graphs and charts, as well as the possibility of some minor user interaction. These requirements are possible with pretty much any front-end library or framework, but some make it much easier than others. The most instantly accessible yet also most difficult option would have been to use some sort of web front end using AJAX. It is possible to display, analyse and visualise large amounts of real time data using Javascript, but it's extremely time consuming and difficult. More reasonable options are Windows Forms and WPF (including Silverlight), but though both technologies are well suited to the task, they are large, complex frameworks, and probably overkill for a small hobby/demo project which was designed as a learning exericise in back-end design and programming, not as an exercise in memorising a particular GUI API. I eventually settled on Resolver One, a spreadsheet program that is a "mash up" of a conventional spreadsheet, a Python program, and a Python IDE. It can display and visualise the results of relatively complex database queries and Python calculations in the form of a spreadsheet, removing the need to get involved in user interface design.</p>

</div>
</body>
</html>
