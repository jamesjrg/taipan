<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html>
<head>

<title>Tai-Pan</title>
<meta http-equiv="content-type" content="text/html;charset=iso-8859-1">

<style type="text/css">
body {font: 100% Sans-serif; background-color: #FFFFFF;}
div.wrapper {font: 100% Sans-serif; background-color: #D2DEFF; width: 94%; padding:20px; margin: 40px auto 40px auto;}
</style>

</head>

<body>

<div class="wrapper">
<h2>Tai-Pan</h2>

<h3>Introduction</h3>

<p>"Tai-Pan" is a C# .NET, SQL Server and Python project written to improve my knowledge of various aspects of computer science and software engineering. The back end code is written in C#, whilst most of the front end - utilising the IronPython spreadsheet Resolver One - is written in IronPython. The system features a large number of heterogeneous, multithreaded C# processes, most interacting via TCP sockets, one acting as a SOAP web service. It makes extensive use of SQL (most of the underlying state of the system is stored in a MS SQL Server instance) and algorithmics (e.g. implementations of B-Trees, hash tables, numerous sorting algorithms, and Geometric Brownian Motion). It also makes use of Microsoft Solver Foundation (a mathematical modelling framework). The project is described by a series of UML diagrams, and partly covered by unit tests.</p>

<p>This web page provides an outline of the project, divided into the following sections:</p>
<ul>
<li><a href="#heng">Software Engineering</a></li>
<li><a href="#hsql">Relational databases</a></li>
<li><a href="#hconcurrency">Concurrency and distributed systems</a></li>
<li><a href="#hmath">Mathematics and algorithmics</a></li>
<li><a href="#hlinks">Links (including source code)</a></li>
</ul>
</p>

<p>&nbsp;</p>

<h3 id="heng">Software Engineering</h3>

<p><img src="images/Deployment.png"/></p>

<p>The system is seperated into several different processes, and some of these processes have multiple copies running at once. Though in the above deployment diagram each process is running on a different node, in reality I test the program by having all the processes running on a single computer and communicating via localhost.</p>

<p>With the exception of "AlgoServer", all of the processes interact as a single system. AlgoServer is an extremely contrived service which was mostly written as an exercise in learning more about various sorting algorithms and complex ordered structures (see <a href="#hmath">math section</a>).</p>

<p>The system makes use of various design patterns both within each process and in the system as a whole. Patterns seen in system as a whole include the n-tier division of data, logic and view (the SQL Server instance, C# processes, and IronPython spreadsheet), and the use of the Bank as a mediator to the database (no other process has write access, leaving the Bank process to manage the stored state of the system).</p>

<p>I used various standard software engineering techniques in the design and construction of the system. Near the beginning of the design process I created several UML diagrams describing various aspects of the system. I have written unit tests against sections of the code to make the system more reliable. As with all projects I have worked on since 2004 (commercial and non-commercial), the source is under version control (in this case git). See the <a href="#hlinks">links section</a> for a link to browse the repository.</p>

<p>There are some things I could have done but didn't due to lack of time. I could have put more focus on unit testing - either by working via test driven development, or at least by having a far high coverage of unit tests. However, most of the system logic is concurrent, spread across multiple processes, and often also stochastic, and hence not suited to unit testing at all. Meanwhile the user interface is sufficiently simple that unit testing isn't really necessary. The multi-process, concurrent aspects of the system which cannot be unit tested would ideally instead be stress tested with a series of automated scripts, but I have not currently built such a test system.</p>

<p>&nbsp;</p>

<h3 id="hsql">Relational databases</h3>

<p><img src="images/DB Schema.png"/></p>

<p>The tangle of foreign key arrows here is a total mess, possibly I should do something to make the diagram more readable, but nevermind. The schema also includes numerous integrity constraints and indexes which are not shown in this diagram.</p>

<p>Within individual tables there are no repeating groups, no non-prime attributes that are functionally determined by only part of a candidate key, no non-prime attributes transitively dependent on a candidate key, and no prime attributes functionally determined by a proper subset of a candidate key. As such the schema is in Boyce-Codd normal form.</p>

<p>Around the top left of the diagram are the classes which hold entries for the economic players represented as C# processes - Company, Trader, and ShippingCompany. "Company" is a base table for "Public Company" and for "Trader", with "inheritance" controlled by CompanyType and a series of constraints.</p>

<p>Along the top are four tables containing historical data on various prices and balances.</p>

<p>The rest of the schema is made of tables which represent various aspects of the modelled system - countries, ports, futures contracts, commodities, etc.</p>

<p>I have made substantial use of stored procedures, and some use of user defined functions and cursors. I have also made some use of SQL Server's spatial geography data type for storing the locations of the ports and for calculating the distances between them.</p>

<p>I have given some basic thought to security and permissions - there are seperate read-only and read-write logins, and processes only use the read-write login where necessary - but complex permissions, views and security schemas would seem rather too contrived for a project being developed and run by a single person.</p>

<p>I have given some slight thought to indexes and efficiency, but I have not yet put any effort into index tuning, execution plan analysis analysis, etc.</p>
</p>

<p>&nbsp;</p>

<h3 id="hconcurrency">Concurrency and distributed systems</h3>

<p>Most of the processes communicate via relatively low-level TCP sockets, though rather than writing my own application-level protocol I am for the most part simply using C#'s XML serialization and deserialization facilities to turn data into strings suitable for writing to a network stream. Some TCP connections consist of one server communicating with multiple peers, whilst others are simply peer-to-peer.</p>

<p>Unlike the other processes, AlgoServer functions as a SOAP web service, and was built using WCF (Windows Communication Foundation). The spreadsheet connects to this with a small proxy assembly, which after a lot of fighting configuration parameters was eventually generated using Microsoft's command line tools.</p>

<p>The processes communicate entirely via asynchronous, fire and forget messages. Many of the messages are either a continuous broadcast or otherwise do not require a reply, and hence for the most part this approach is the correct one to take. The interaction between traders and shipping companies involves an exchange of several messages linked together, and so would ideally be better suited to using a system of callbacks than continous polling. I have previously had a small amount of experience working with event-driven networking with Python (Twisted) and Javascript (MochiKit and AJAX).</p>

<p>The processes are themselves multithreaded, and so have to pay some attention to sharing data between threads in a safe manner, though the processes are sufficiently small that this was not a major undertaking. Data shared between threads is stored in instances of a synchronised, multi-headed queue structure, whereby the queue maintains a seperate head index for each subscribing thread.</p>

<p>Below is a sequence diagram showing the network messaging sent as a result of a Trader receiving a forecast of a surplus of a given commodity at a given port at some point in the future. A real system would likely have more acknowledgement messages and error checking, but I have kept things fairly simple:</p>

<p><img src="images/SequenceSurplus.png"/></p>

<p>If a trader receives a message indicating a predicted future shortage of a commodity at a port, a similar flow of actions results as for a predicted surplus:</p>

<p><img src="images/SequenceShortage.png"/></p>

<p>&nbsp;</p>

<h3 id="hmath">Mathematics and algorithmics</h3>

<p>A user interface to the system is provided in the form of an IronPython-based spreadsheet using a spreadsheet program called "Resolver One", billed as a "programable spreadsheet" or as a "mash-up of a spreadsheet and an IDE". Rather than allowing macros to be run against the spreadsheet in a limited fashion (as with Excel), in Resolver One the entire sheet is an IronPython script that you are free to modify. It is extremely flexible - you can load external .NET or Python libraries and write code utilising them to manipulate the cells in the workbook, and you can also add clickable buttons and drop downs to cells for user interaction.</p>

<p><img src="images/gbm.png"/></p>

<p>There are various prices and values that fluctuate in the model. These include commodity prices at each port (which generally follow Geometric Brownian Motion but are subject to random price jumps), FX rates (entirely determined by Geometric Brownian Motion), share prices (entirely determined by Geometric Brownian Motion), and bank balances (determined by the interactions between the various players in the system). The first two sheets of the workbook (the sheets being the various tabs at the bottom of the above screenshot) include buttons to fetch the most recent USD-adjusted commodity prices or FX rates from the database, buttons to optionally create predicted future random walk data points, and buttons to graph this data by instantiating a WPF graph window from a .NET assembly. The WPF chart code is almost entirely the public domain work of other people, with only minor changes.</p>

<p>The GBM sequences are produced using a tiny custom class library written in C# and shared by both the processes in the main system and the IronPython spreadsheet code. This library provides functions for Gaussian and Geometric Brownian sequences, the first based on the Box-Muller transformation, the latter based on sampling the former.</p>

<p>The following six sheets display the results of various SQL queries on the database, aggregating summary data in various ways.</p>

<p>The next sheet after the "Country Summary" is the "Travelling Freighter Problem", a variation on the classic NP-hard "Travelling Salesman Problem". The Travelling Salesman Problem is: "Given a list of cities and their pairwise distances, find the shortest possible tour that visits each city exactly once.". This is a classic problem in the study of optimization methods, and there are numerous approaches to solving it - a simple greedy approximation algorithm, treating the problem as a graph and using a minimum spanning tree approximation, matrix flow approaches, and surely many others. One approach is to treat it as a generic linear programming problem - that is, a problem defined as minimizing (or maximizing) a given linear function subject to given linear inequalities. I took some public domain C# code that used Microsoft's Solver Foundation library to solve the TSP as a linear programming problem and converted it to IronPython (easier said than done given Solver's reliance on typed user-defined classes and implicit C# type conversions). I then placed it into the Resolver spreadsheet, and added drop down menus to select a group of ports from the database. SQL Server's spatial data functions are used to find out the length of the arc between each port (ignoring the fact that land is often in the way, but nevermind), and this data is then fed to Solver, and the optimum tour output to the spreadsheet.</p>

<p>I made this visualisation using UML tools, it is not automatically generated by the spreadsheet:</p>

<p><img src="images/TFP.png"/></p>

<p>The result page in the spreadsheet:</p>

<p><img src="images/tfp_result.png"/></p>

<p>When working for Thomson Airways I worked on a much larger optimization system used for airline crew planning, with thousands of rules and constraints, though my role there only involving maintaining the high level code that stated the system's rules and constraints, and did not require any understanding of the underlying system and linear programming.</p>

<p>The final sheet connects to a C# web service called "AlgoServer". This service implements various complex data structures and sorting algorithms: insertion sort, merge sort, heap sort, quick sort, randomized quick sort, counting sort, chained hash map, binary search tree, red-black tree, B-tree. It provides a SOAP web service with several methods:</p>

<ul>
<li>It provides a method called "TimeSort" which takes a sorting method, an array to be sorted, and a number of iterations to repeat the sorting on the original array. Returned is not only the sorted list, but also the time taken to perform the iterations. The spreadsheet provides dropdowns to select a number of different algorithms, and fields to choose a size of randomized list to create and the number of iterations to perform, and then displays the comparative time that algorithm's iterations took on the randomized list.
</li>
<li>There is a method to create a data structure of given type. On calling this method the server returns an ID which can the client can then include as a parameter when requesting operations to be made on that data structure (e.g. search, insert, remove), or to delete it. However, these methods are not currently utilised by the spreadsheet.</li>
</ul>

<p><img src="images/sorting.png"/></p>

<p>&nbsp;</p>

<h3 id="hlinks">Links (including source code)</h3>

<p>The repository for the project is at <a href="http://github.com/jamesjrg/taipan">http://github.com/jamesjrg/taipan</a>.</p>

<p>A database of all the projects I have ever worked on is available at <a href="http://www.jameswritesstuff.co.uk/sde/">http://www.jameswritesstuff.co.uk/sde/</a>.</p>

</div>
</body>
</html>
