<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html>
<head>

<title>Tai-Pan</title>
<meta http-equiv="content-type" content="text/html;charset=iso-8859-1">

<style type="text/css">
body {font: 100% Sans-serif; background-color: #FFFFFF;}
div.wrapper {font: 100% Sans-serif; background-color: #D2DEFF; width: 94%; padding:20px; margin: 40px auto 40px auto;}
</style>

</head>

<body>

<div class="wrapper">
<h2>Tai-Pan</h2>

<h3>Introduction</h3>

<p>"Tai-Pan" is a C# .NET project that simulates a trading economy. In order to improve my knowledge of .NET, as well as the theory behind relational database design and management, concurrency, and software engineering, the project was purposefully designed to be fairly complex. As such there are a large number of heterogeneous, multi-threaded client and server processes broadcasting and polling XML messages, whilst simultaneously interacting with a SQL Server database that holds most of the underlying state of the system. The front end makes use of a commercial spreadsheet/Python IDE "mashup" called Resolver One, which allows for a Python program that constantly executes SQL queries on the database and displays the results in spreadsheet cells.</p>

<p>The purpose of this web page is to demonstrate what I learnt. Click one of the headings below to jump to a section which interests you:</p>
<ul>
<li><a href="#heng">Software Engineering (software design, UML, unit testing, source control, etc)</a></li>
<li><a href="#hsql">SQL and SQL Server</a></li>
<li><a href="#hconcurrency">Concurrency and networking</a></li>
<li><a href="#hdotnet">C# and .NET</a></li>
</ul>
</p>

<p>&nbsp;</p>

<h3 id="heng">Software Engineering</h3>

<p>[UML communication diagram - several processes, XML, SQL, database]</p>

<p>xxx brief explanation of diagram. xxx explain messaging protocol - xml.</p>

<p>blah blah all the processes are enitrely seperate and communicate via [netowork protocol], and so the system is (or at least could be) very distributed. The following deployment diagram demonstrates this:</p>

<p><img src="images/Deployment.png"/></p>

<p>xxx in the concurrency section of this document there is a UML sequence diagram which models in closer detail the communication between the Traders and the DomesticCompanies, and another UML diagram showing the database schema in the SQL section. I haven't exported a class diagram for the C# code because a) it would be very easy to do and so I wouldn't learn anything by doing so and b) due to the distributed nature of the system the class structure for each individual process is actually pretty simple. I have dealt with more complicated class hierarchies on other projects.</p>

<p>xxx blah blah test driven development (Isotoma, concurrency, etc)</p>

<p>For source control I used Git. I have used source control on almost every single software project I have been involved in since 2004, both commercial and non-commercial. I have mostly used SVN and CVS, but for a few recent projects, including this one, I have used Git. I can see how the distributed nature of Git, and it's emphasis on branching and merging, makes it very well suited to distributed open source projects. For projects like this one, with just one developer - or in fact any project which doesn't make substantial use of branching and merging - I'm not convinced Git is any more productive to use than SVN.</p>

<p>The git repository for the project is at <a href="http://github.com/jamesjrg/taipan">http://github.com/jamesjrg/taipan</a></p>

<h3 id="hsql">SQL and SQL Server</h3>

<p><img src="images/DB Schema.png"/></p>

<p>The tangle of foreign key arrows here is a total mess, possibly I should do something to make the diagram more readable, but nevermind.</p>

<p>In the centre of the diagram are some classes which hold entries for the Trader, DomesticCompany and ShippingCompany C# processes. "Company" is a base table for "Public Company" and for "Trader". "Public Company" is in turn a base table for "DomesticCompany". blah blah explanation of diagram.</p>

<p>There are four tables containing historical data on monetary balances and values, each of which uses a trigger to update the current price attribute in the table for which they are recording historical data. xxx therefore there are four redunadntly stored values, as a search of the historical data tables whenever a value or balance was required would be very inefficient. Within individual tables there are no repeating groups, no non-prime attributes that are functionally determined by only part of a candidate key, no non-prime attributes transitively dependent on a candidate key, and no prime attributes functionally determined by a proper subset of a candidate key. As such the schema is in Boyce-Codd normal form.</p>

<p>blah blah stored procedures, views, etc, talk about where I've used any of these things before (sde, forkd, tui).</p>
<p>blah blah blah tuning and efficiency and indexes very large tables</p>

<p>blah blah didn't use LINQ because I wanted to use some fairly complex SQL. My prior experience of object-relation mappers (in Python) is that they aren't much use for complex queries, though it is possible LINQ is better, and I may attempt to convert some of the queries to LINQ in future.</p>

<h3 id="hconcurrency">Concurrency and networking</h3>

<p>[UML diagram of interactions]

<p>blah blah explanation of diagram</p>

<p>blah blah concurrency with processes and within processes with threading, blah blah contract for movements of goods and locking process</p>

<p>blah blah in terms of formal testing and guarantees of reliability regarding the concurrent aspects of the system, I have not currently done much serious work. Concurrency is not well suited to normal unit testing, and effectively setting up automated tests of concurrent systems is a very large topic. I may do further reading on this subject in future.</p>

<p>As far as networking efficiency is concerned, here too I have done limited work - I have just let WCF handle the details of network communication. Here too I could do more work in future, though in reality any network code below the application level is generally written in C++ or Java, not C#. blah still, might be nice to build on what I have learnt about networking blah blah mention I have done some slightly complex networking stuff before (blah blah mention Twisted at Isotoma and my threaded Java app and TCP at Opera).</p>

<h3 id="hdotnet">C# and .NET</h3>

<p>[image of some sort of interactive real time data stream]</p>
<p>[image of commodity price variation graph]</p>

<p>blah blah GBM</p>

<p>blah blah compare to C++ and Java and Python</p>
<p>blah blah Resolver One. blah blah considered web front end, but I wanted an interactive interface to large amounts of real time data, whilst maintaining a responsive GUI. This set of requirements is very difficult to meet with Javascript, Flash, Silverlight, etc. I also wanted to have the option of one day adding more complex visualisations such as graphs and charts, which makes WPF attractive, and which pretty much rules out HTML/CSS/Javascript altogether. </p>

</div>
</body>
</html>
